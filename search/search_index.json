{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HOHQMesh \u00b6 HOHQMesh , the High Order Hex-Quad Mesher , is an open-source mesh generator that automatically creates quadrilateral/hexahedral meshes with high-order boundary information. Getting started \u00b6 HOHQMesh can be used via HOHQMesh.jl , a Julia package that provides an interface to HOHQMesh and that supplies precompiled executables for Linux, macOS, Windows, and FreeBSD. If you would like to use HOHQMesh directly from the command line, please continue reading the next sections for instructions on how to obtain the sources and compile HOHQMesh yourself. Install with Spack \u00b6 You can install HOHQMesh using the Spack package manager . To install the HOHQMesh with Spack, git clone https://github.com/spack/spack.git ~/spack source ~/spack/share/spack/setup-env.sh spack install hohqmesh@main This will install HOHQMesh and all of its dependencies (including FTObjectLibrary) from source code. Once installed, HOHQMesh can be added to your environment using spack load hohqmesh Obtaining the sources \u00b6 You can download the latest HOHQMesh release from GitHub. Make sure to get the tarball named HOHQMesh-vVERSION.tar.gz , as it already contains the required sources for the FTObjectLibrary dependency, and unpack it with tar xf HOHQMesh-vVERSION.tar.gz . Alternatively, you can build HOHQMesh directly from the latest sources in the main branch. In this case, you need enter the clone directory and execute ./Utilities/bootstrap before proceeding, which will download the FTObjectLibrary sources for you. This step is required only once. Building \u00b6 Enter the HOHQMesh directory and execute make This will build HOHQMesh using the gfortran compiler by default. The compiler choice can be overriden by passing FC=<pathToCompiler> to make . You can further pass the -jN option to make (with N being a non-negative integer), which will use N parallel processes. For example, to build HOHQMesh specifically with the Fortran compiler gfortran-10 and with 4 parallel processes, execute make -j 4 FC = gfortran-10 Testing \u00b6 After building HOHQMesh, you can verify that everything works as expected by running the internal test suite. To execute the tests, type ./HOHQMesh -test -path <pathToBenchmarks> where <pathToBenchmarks> is the path to the HOHQMesh directory. If you are inside the HOHQMesh directory, you can also omit the -path option, as it defaults to . . Generating a mesh \u00b6 To mesh a control file, type ./HOHQMesh -f <pathToControlFile> where -f allows you to provide the path to the control file for which you want to create your mesh. Authors \u00b6 HOHQMesh was initiated by David A. Kopriva , who is also the principal developer. The full list of contributors can be found in the Authors section. License and contributing \u00b6 HOHQMesh is licensed under the MIT license (see the License section).","title":"Home"},{"location":"#hohqmesh","text":"HOHQMesh , the High Order Hex-Quad Mesher , is an open-source mesh generator that automatically creates quadrilateral/hexahedral meshes with high-order boundary information.","title":"HOHQMesh"},{"location":"#getting-started","text":"HOHQMesh can be used via HOHQMesh.jl , a Julia package that provides an interface to HOHQMesh and that supplies precompiled executables for Linux, macOS, Windows, and FreeBSD. If you would like to use HOHQMesh directly from the command line, please continue reading the next sections for instructions on how to obtain the sources and compile HOHQMesh yourself.","title":"Getting started"},{"location":"#install-with-spack","text":"You can install HOHQMesh using the Spack package manager . To install the HOHQMesh with Spack, git clone https://github.com/spack/spack.git ~/spack source ~/spack/share/spack/setup-env.sh spack install hohqmesh@main This will install HOHQMesh and all of its dependencies (including FTObjectLibrary) from source code. Once installed, HOHQMesh can be added to your environment using spack load hohqmesh","title":"Install with Spack"},{"location":"#obtaining-the-sources","text":"You can download the latest HOHQMesh release from GitHub. Make sure to get the tarball named HOHQMesh-vVERSION.tar.gz , as it already contains the required sources for the FTObjectLibrary dependency, and unpack it with tar xf HOHQMesh-vVERSION.tar.gz . Alternatively, you can build HOHQMesh directly from the latest sources in the main branch. In this case, you need enter the clone directory and execute ./Utilities/bootstrap before proceeding, which will download the FTObjectLibrary sources for you. This step is required only once.","title":"Obtaining the sources"},{"location":"#building","text":"Enter the HOHQMesh directory and execute make This will build HOHQMesh using the gfortran compiler by default. The compiler choice can be overriden by passing FC=<pathToCompiler> to make . You can further pass the -jN option to make (with N being a non-negative integer), which will use N parallel processes. For example, to build HOHQMesh specifically with the Fortran compiler gfortran-10 and with 4 parallel processes, execute make -j 4 FC = gfortran-10","title":"Building"},{"location":"#testing","text":"After building HOHQMesh, you can verify that everything works as expected by running the internal test suite. To execute the tests, type ./HOHQMesh -test -path <pathToBenchmarks> where <pathToBenchmarks> is the path to the HOHQMesh directory. If you are inside the HOHQMesh directory, you can also omit the -path option, as it defaults to . .","title":"Testing"},{"location":"#generating-a-mesh","text":"To mesh a control file, type ./HOHQMesh -f <pathToControlFile> where -f allows you to provide the path to the control file for which you want to create your mesh.","title":"Generating a mesh"},{"location":"#authors","text":"HOHQMesh was initiated by David A. Kopriva , who is also the principal developer. The full list of contributors can be found in the Authors section.","title":"Authors"},{"location":"#license-and-contributing","text":"HOHQMesh is licensed under the MIT license (see the License section).","title":"License and contributing"},{"location":"appendix/","text":"Appendix \u00b6 Appendix A: Additions for ISM-v2 \u00b6 The ISM-v2 adds edge information to the mesh file. The first line of the mesh file will state that fact, that is, if the first line is ISM-V2 then it will have the edge information. Line 1: ISM-V2 The second line now also includes the number of edges in the mesh as follows: #nodes, #edges, #elements, polynomial order of boundary edges The edges are read immediately after the nodes. For each edge the following are listed: start node ID, end node ID, element ID on left, element ID on right, side of left element, side of right element These are the quantities that are computed in Alg. 148 of \"Implementing Spectral Methods\". If the edge is a boundary edge, then the second side element will be ID = 0 and the side of that element will be 0. If the sides have indices that increase in opposite directions, then the last column in the data will be negative.\ufffc Appendix B: Summary of Boundary Curve Definitions \u00b6 Defining a parametric equation: \\begin{PARAMETRIC_EQUATION_CURVE} name = <name> xEqn = x(t) = <x-equation> yEqn = y(t) = <y-equation> zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} Defining a Spline: \\begin{SPLINE_CURVE} name = <name> nKnots = # of nodes \\begin{SPLINE_DATA} t x y z . . . \\end{SPLINE_DATA} \\end{SPLINE_CURVE} Defining a Straight Line \\begin{END_POINTS_LINE} name = <name> xStart = [x,y,0] xEnd = [x,y,0] \\end{END_POINTS_LINE} Defining a Circular Arc \\begin{CIRCULAR_ARC} name = <name> units =degrees/radians(Optional.Default:radians) center = [x,y,0] radius = r start angle = Tstart end angle = Tend \\end{CIRCULAR_ARC} Chaining curves \\begin{CHAIN} name = <Chain Name> First curve definition Second curve definition ... Last curve definition \\end{CHAIN}\ufffc Appendix C: Summary of Model Definition Blocks \u00b6 No inner boundaries: \\begin{MODEL} \\begin{OUTER_BOUNDARY} First curve definition Second curve definition ... Last curve definition \\end{OUTER_BOUNDARY} \\end{MODEL} No outer boundaries: \\begin{MODEL} \\begin{INNER_BOUNDARIES} First chain definition Second chain definition ... Last chain definition \\end{INNER_BOUNDARIES} \\end{MODEL} Both inner and outer boundaries: \\begin{MODEL} \\begin{OUTER_BOUNDARY} First curve definition Second curve definition ... Last curve definition \\end{OUTER_BOUNDARY} \\begin{INNER_BOUNDARIES} First chain definition Second chain definition ... Last chain definition \\end{INNER_BOUNDARIES} \\end{MODEL} Appendix D: Summary of the Control Block \u00b6 The control block (required): \\begin{CONTROL_INPUT} ... \\end{CONTROL_INPUT} The run parameters (required): \\begin{RUN_PARAMETERS} mesh file name = <pathToMeshFile> plot file name = <pathToPlotFile> stats file name = <pathToStatsFile> **or** none mesh file format = ISM **or** ISM-v2 polynomial order = Boundary polynomial order plot file format = skeleton **or** sem \\end{RUN_PARAMETERS} To specify the background grid (required): \\begin{BACKGROUND_GRID} background grid size = [x,y,0.0] \\end{BACKGROUND_GRID} if there is an outer boundary curve in the model. If there is no outer boundary, just an implied box, then use \\begin{BACKGROUND_GRID} x0 = [xLeft, yBottom, 0.0] dx = [dx, dy, 0.0] N = [Nx,nY,0] \\end{BACKGROUND_GRID} Smoothing is recommended (highly!) \\begin{SPRING_SMOOTHER} smoothing = ON **or** OFF smoothing type = LinearAndCrossbarSpring **or* LinearSpring number of iterations = typically 20-30 \\end{SPRING_SMOOTHER} If manual local refinement is desired, include \\begin{REFINEMENT_REGIONS} ... \\END{REFINEMENT_REGIONS} with blocks of the types \\begin{REFINEMENT_CENTER} type = smooth **or** sharp x0 = [xCenter,-yCenter,0.0] h = mesh size w = radial extent \\end{REFINEMENT_CENTER} \\begin{REFINEMENT_LINE} type = smooth **or** sharp x0 = [xStart,yStart,0.0] x1 = [xEnd,yEnd,0.0] h = mesh size w = width of line \\end{REFINEMENT_LINE} To generate 3D meshes, add an extrusion algorithm, either \\begin{SIMPLE_EXTRUSION} direction = 1 (=x), 2 (=y), 3 (=z) height = height of extrusion subdivisions = how many elements in the extrusion direction start surface name = name of start surface end surface name = name of end surface \\end{SIMPLE_EXTRUSION} or to sweep-rotate a 2D mesh, \\begin{SIMPLE_ROTATION} direction = 1 (=x), 2 (=y), 3 (=z) = rotation axis rotation angle factor = fraction of pi subdivisions = number of elements in direction start surface name = name of start surface end surface name = name of end surface \\end{SIMPLE_ROTATION} or to sweep along a curve, \\begin{SWEEP_ALONG_CURVE} algorithm = Hanson (optional) subdivisions per segment = Subdivisions for each curve in sweep curve chain start surface name = name of start surface end surface name = name of end surface \\end{SWEEP_ALONG_CURVE} For the sweep-curve, add the curve to the model: \\begin{SWEEP_CURVE} ... Curve chain ... \\end{SWEEP_CURVE} and if scaling along the sweep is desired, also add \\begin{SWEEP_SCALE_FACTOR} ... chain of PARAMETRIC_EQUATIONs \\end{SWEEP_SCALE_FACTOR} to the model. If the SIMPLE_EXTRUSION is used, bottom topography can be optionally added to the model \\begin{TOPOGRAPHY} eqn = f(x,y) = some function of (x,y) as an equation \\end{TOPOGRAPHY} Appendix E: ABAQUS mesh file format \u00b6 The Abaqus mesh file format is common in the finite element community. The ABAQUS mesh file should use the .inp extension. The standard Abaqus format includes a list of node data and a list of element connectivity information. In this sense it is similar to the ISM format without high-order boundary information. The standard Abaqus format encodes a straight sided (linear) mesh. Herein, we decribe an extended version to the ABAQUS format, divided into two parts. The first parts includes the standard Abaqus node and element lists. The second part encodes the high-order boundary information and naming information created by HOHQMesh. This second set of information is output in such a way that it will be ignored by standard ABAQUS file parsers, but the information is available if desired. For example, a .inp mesh file created by HOHQMesh can be parsed into Trixi.jl to create high-order curved AMR meshes. First, we describe the linear mesh skeleton encoded in the standard Abaqus format. For this example we use a quadrilateral mesh with 122 corner nodes and 103 elements: *Heading File created by HOHQMesh *NODE 1, x1, y1, z1 2, x2, y2, z2 . . . 122, x122, y122, z122 *ELEMENT, type=CPS4, ELSET=Surface1 1, 1, 2, 9, 8 2, 2, 3, 10, 9 . . . 103, 7, 122, 87, 8 Note that the first column in the node or element list is used for indexing purposes. The four other indices in each line of the *ELEMENT list are the corner IDs that dictate the element connectivity. These corner IDs are listed to guarantee right-handed element just as with the ISM format. The Abaqus element type CPS4 corresponds to a quadrilateral element. For the three-dimensional variant of this mesh file output we use *ELEMENT, type=C3D8, ELSET=Volume1 where C3D8 corresponds to a hexahedron. The standard Abaqus file format can be used to create a straight-sided mesh. The high-order boundary information and curvature generated by HOHQMesh is output in the second portion of this mesh file. We demarcate between the two portions of the mesh file with the comment line ** ***** HOHQMesh boundary information ***** ** In the Abaqus format anything prefaced with ** is treated as a comment and is ignored by an ABAQUS file parser. Therefore, all the HOHQMesh information output in the second portion of the mesh file is prefaced with ** to act as an Abaqus comment. After the above comment line the mesh file gives the polynomial degree of the boundary curves in the mesh. Then, this mesh file format closely resembles the ISM format albeit slightly reordered. First, there is a list of the element connectivity, curved edge checks, and polynomial interpolant information after which comes the list of boundary names. The order of the boundary names is a final difference in the mesh format. The Abaqus format and libraries that use it (e.g. p4est ) require the boundary labels in a particular order. In general, we can think of a quadrilateral element to have sides labeled +y ----------------- | | | ^ y | -x | | | +x | | | | ---> x | ----------------- -y For this mesh file output the boundary labels are reordered to adopt the order convention of -x +x -y +y . For comparison, the default HOHQMesh ordering used by ISM or ISM-v2 gives the boundary labels in the order -y +x +y -x . Similarly, the boundary names are reordered for the 3D HOHQMesh output to adopt the convention -x +x -y +y -z +z compared to the ISM formatting of 3D boundary names which is -y +y -z +x +z -x .","title":"Appendix"},{"location":"appendix/#appendix","text":"","title":"Appendix"},{"location":"appendix/#appendix-a-additions-for-ism-v2","text":"The ISM-v2 adds edge information to the mesh file. The first line of the mesh file will state that fact, that is, if the first line is ISM-V2 then it will have the edge information. Line 1: ISM-V2 The second line now also includes the number of edges in the mesh as follows: #nodes, #edges, #elements, polynomial order of boundary edges The edges are read immediately after the nodes. For each edge the following are listed: start node ID, end node ID, element ID on left, element ID on right, side of left element, side of right element These are the quantities that are computed in Alg. 148 of \"Implementing Spectral Methods\". If the edge is a boundary edge, then the second side element will be ID = 0 and the side of that element will be 0. If the sides have indices that increase in opposite directions, then the last column in the data will be negative.\ufffc","title":"Appendix A: Additions for ISM-v2"},{"location":"appendix/#appendix-b-summary-of-boundary-curve-definitions","text":"Defining a parametric equation: \\begin{PARAMETRIC_EQUATION_CURVE} name = <name> xEqn = x(t) = <x-equation> yEqn = y(t) = <y-equation> zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} Defining a Spline: \\begin{SPLINE_CURVE} name = <name> nKnots = # of nodes \\begin{SPLINE_DATA} t x y z . . . \\end{SPLINE_DATA} \\end{SPLINE_CURVE} Defining a Straight Line \\begin{END_POINTS_LINE} name = <name> xStart = [x,y,0] xEnd = [x,y,0] \\end{END_POINTS_LINE} Defining a Circular Arc \\begin{CIRCULAR_ARC} name = <name> units =degrees/radians(Optional.Default:radians) center = [x,y,0] radius = r start angle = Tstart end angle = Tend \\end{CIRCULAR_ARC} Chaining curves \\begin{CHAIN} name = <Chain Name> First curve definition Second curve definition ... Last curve definition \\end{CHAIN}\ufffc","title":"Appendix B: Summary of Boundary Curve Definitions"},{"location":"appendix/#appendix-c-summary-of-model-definition-blocks","text":"No inner boundaries: \\begin{MODEL} \\begin{OUTER_BOUNDARY} First curve definition Second curve definition ... Last curve definition \\end{OUTER_BOUNDARY} \\end{MODEL} No outer boundaries: \\begin{MODEL} \\begin{INNER_BOUNDARIES} First chain definition Second chain definition ... Last chain definition \\end{INNER_BOUNDARIES} \\end{MODEL} Both inner and outer boundaries: \\begin{MODEL} \\begin{OUTER_BOUNDARY} First curve definition Second curve definition ... Last curve definition \\end{OUTER_BOUNDARY} \\begin{INNER_BOUNDARIES} First chain definition Second chain definition ... Last chain definition \\end{INNER_BOUNDARIES} \\end{MODEL}","title":"Appendix C: Summary of Model Definition Blocks"},{"location":"appendix/#appendix-d-summary-of-the-control-block","text":"The control block (required): \\begin{CONTROL_INPUT} ... \\end{CONTROL_INPUT} The run parameters (required): \\begin{RUN_PARAMETERS} mesh file name = <pathToMeshFile> plot file name = <pathToPlotFile> stats file name = <pathToStatsFile> **or** none mesh file format = ISM **or** ISM-v2 polynomial order = Boundary polynomial order plot file format = skeleton **or** sem \\end{RUN_PARAMETERS} To specify the background grid (required): \\begin{BACKGROUND_GRID} background grid size = [x,y,0.0] \\end{BACKGROUND_GRID} if there is an outer boundary curve in the model. If there is no outer boundary, just an implied box, then use \\begin{BACKGROUND_GRID} x0 = [xLeft, yBottom, 0.0] dx = [dx, dy, 0.0] N = [Nx,nY,0] \\end{BACKGROUND_GRID} Smoothing is recommended (highly!) \\begin{SPRING_SMOOTHER} smoothing = ON **or** OFF smoothing type = LinearAndCrossbarSpring **or* LinearSpring number of iterations = typically 20-30 \\end{SPRING_SMOOTHER} If manual local refinement is desired, include \\begin{REFINEMENT_REGIONS} ... \\END{REFINEMENT_REGIONS} with blocks of the types \\begin{REFINEMENT_CENTER} type = smooth **or** sharp x0 = [xCenter,-yCenter,0.0] h = mesh size w = radial extent \\end{REFINEMENT_CENTER} \\begin{REFINEMENT_LINE} type = smooth **or** sharp x0 = [xStart,yStart,0.0] x1 = [xEnd,yEnd,0.0] h = mesh size w = width of line \\end{REFINEMENT_LINE} To generate 3D meshes, add an extrusion algorithm, either \\begin{SIMPLE_EXTRUSION} direction = 1 (=x), 2 (=y), 3 (=z) height = height of extrusion subdivisions = how many elements in the extrusion direction start surface name = name of start surface end surface name = name of end surface \\end{SIMPLE_EXTRUSION} or to sweep-rotate a 2D mesh, \\begin{SIMPLE_ROTATION} direction = 1 (=x), 2 (=y), 3 (=z) = rotation axis rotation angle factor = fraction of pi subdivisions = number of elements in direction start surface name = name of start surface end surface name = name of end surface \\end{SIMPLE_ROTATION} or to sweep along a curve, \\begin{SWEEP_ALONG_CURVE} algorithm = Hanson (optional) subdivisions per segment = Subdivisions for each curve in sweep curve chain start surface name = name of start surface end surface name = name of end surface \\end{SWEEP_ALONG_CURVE} For the sweep-curve, add the curve to the model: \\begin{SWEEP_CURVE} ... Curve chain ... \\end{SWEEP_CURVE} and if scaling along the sweep is desired, also add \\begin{SWEEP_SCALE_FACTOR} ... chain of PARAMETRIC_EQUATIONs \\end{SWEEP_SCALE_FACTOR} to the model. If the SIMPLE_EXTRUSION is used, bottom topography can be optionally added to the model \\begin{TOPOGRAPHY} eqn = f(x,y) = some function of (x,y) as an equation \\end{TOPOGRAPHY}","title":"Appendix D: Summary of the Control Block"},{"location":"appendix/#appendix-e-abaqus-mesh-file-format","text":"The Abaqus mesh file format is common in the finite element community. The ABAQUS mesh file should use the .inp extension. The standard Abaqus format includes a list of node data and a list of element connectivity information. In this sense it is similar to the ISM format without high-order boundary information. The standard Abaqus format encodes a straight sided (linear) mesh. Herein, we decribe an extended version to the ABAQUS format, divided into two parts. The first parts includes the standard Abaqus node and element lists. The second part encodes the high-order boundary information and naming information created by HOHQMesh. This second set of information is output in such a way that it will be ignored by standard ABAQUS file parsers, but the information is available if desired. For example, a .inp mesh file created by HOHQMesh can be parsed into Trixi.jl to create high-order curved AMR meshes. First, we describe the linear mesh skeleton encoded in the standard Abaqus format. For this example we use a quadrilateral mesh with 122 corner nodes and 103 elements: *Heading File created by HOHQMesh *NODE 1, x1, y1, z1 2, x2, y2, z2 . . . 122, x122, y122, z122 *ELEMENT, type=CPS4, ELSET=Surface1 1, 1, 2, 9, 8 2, 2, 3, 10, 9 . . . 103, 7, 122, 87, 8 Note that the first column in the node or element list is used for indexing purposes. The four other indices in each line of the *ELEMENT list are the corner IDs that dictate the element connectivity. These corner IDs are listed to guarantee right-handed element just as with the ISM format. The Abaqus element type CPS4 corresponds to a quadrilateral element. For the three-dimensional variant of this mesh file output we use *ELEMENT, type=C3D8, ELSET=Volume1 where C3D8 corresponds to a hexahedron. The standard Abaqus file format can be used to create a straight-sided mesh. The high-order boundary information and curvature generated by HOHQMesh is output in the second portion of this mesh file. We demarcate between the two portions of the mesh file with the comment line ** ***** HOHQMesh boundary information ***** ** In the Abaqus format anything prefaced with ** is treated as a comment and is ignored by an ABAQUS file parser. Therefore, all the HOHQMesh information output in the second portion of the mesh file is prefaced with ** to act as an Abaqus comment. After the above comment line the mesh file gives the polynomial degree of the boundary curves in the mesh. Then, this mesh file format closely resembles the ISM format albeit slightly reordered. First, there is a list of the element connectivity, curved edge checks, and polynomial interpolant information after which comes the list of boundary names. The order of the boundary names is a final difference in the mesh format. The Abaqus format and libraries that use it (e.g. p4est ) require the boundary labels in a particular order. In general, we can think of a quadrilateral element to have sides labeled +y ----------------- | | | ^ y | -x | | | +x | | | | ---> x | ----------------- -y For this mesh file output the boundary labels are reordered to adopt the order convention of -x +x -y +y . For comparison, the default HOHQMesh ordering used by ISM or ISM-v2 gives the boundary labels in the order -y +x +y -x . Similarly, the boundary names are reordered for the 3D HOHQMesh output to adopt the convention -x +x -y +y -z +z compared to the ISM formatting of 3D boundary names which is -y +y -z +x +z -x .","title":"Appendix E: ABAQUS mesh file format"},{"location":"assumptions-and-algorithms/","text":"Assumptions and Algorithms \u00b6 This is a collection of comments on some of the approximations and assumptions made in developing HOHQMesh. It is not exhaustive. It is also not in any particular order. When checking to see whether or not two curves cross (when reading in the model), actual intersection is not tested. Rather, it looks to see if one or two points end up within the same bounding box. The assumption is that if the curves are that close together then the resolution is not good enough to generate a mesh anyway. [CheckForBoundaryIntersections] The algorithm for parallel transport along a curve to sweep three dimensional meshes is only second order accurate. A 4th order scheme is published, but not implemented yet. In giving the background mesh size, the code assumes that the user knows this size is sufficiently small to be able to reasonably resolve the boundary curves. Choosing the background mesh h = 1 and the curves of size 0.1 cannot resolve a curve. A linear search is used in \"sizeFunctionMinimumOnBox\" to find the minimum of the size function. A note is included in the subroutine that that should be switched to a good minimization algorithm. Mesh sizes are determined (in part) by how close two curves are together (or how close a curve is to itself since the region they surround does not have to be convex). A bare minimum is three elements between since two will be deleted. The mesh size at any point along a curve is determined by a linear search through all points along the curve and all points along other curves. This is pretty bad, but meshing times so far have been su-second so there has been little incentive to get picky. The sizer controls spread the region out using a Gaussian profile. The square root (for distance) and exponentials used are very expensive. Meshing times for meshes with sizer controls are significantly longer than those without. Since the actual shape of the regions is not important, consider using a quadratic polynomial approximation to a Gaussian instead to perhaps speed things up. In practice, of all the horrendous algorithms, the size controls seem to be the only ones that are costly.","title":"Assumptions and Algorithms"},{"location":"assumptions-and-algorithms/#assumptions-and-algorithms","text":"This is a collection of comments on some of the approximations and assumptions made in developing HOHQMesh. It is not exhaustive. It is also not in any particular order. When checking to see whether or not two curves cross (when reading in the model), actual intersection is not tested. Rather, it looks to see if one or two points end up within the same bounding box. The assumption is that if the curves are that close together then the resolution is not good enough to generate a mesh anyway. [CheckForBoundaryIntersections] The algorithm for parallel transport along a curve to sweep three dimensional meshes is only second order accurate. A 4th order scheme is published, but not implemented yet. In giving the background mesh size, the code assumes that the user knows this size is sufficiently small to be able to reasonably resolve the boundary curves. Choosing the background mesh h = 1 and the curves of size 0.1 cannot resolve a curve. A linear search is used in \"sizeFunctionMinimumOnBox\" to find the minimum of the size function. A note is included in the subroutine that that should be switched to a good minimization algorithm. Mesh sizes are determined (in part) by how close two curves are together (or how close a curve is to itself since the region they surround does not have to be convex). A bare minimum is three elements between since two will be deleted. The mesh size at any point along a curve is determined by a linear search through all points along the curve and all points along other curves. This is pretty bad, but meshing times so far have been su-second so there has been little incentive to get picky. The sizer controls spread the region out using a Gaussian profile. The square root (for distance) and exponentials used are very expensive. Meshing times for meshes with sizer controls are significantly longer than those without. Since the actual shape of the regions is not important, consider using a quadratic polynomial approximation to a Gaussian instead to perhaps speed things up. In practice, of all the horrendous algorithms, the size controls seem to be the only ones that are costly.","title":"Assumptions and Algorithms"},{"location":"authors/","text":"Authors \u00b6 HOHQMesh's development is coordinated by David A. Kopriva, who is the principal developer and main contributor. In addition, there are contributors who have provided substantial additions or modifications. Together, these two groups form authors as mentioned in the the License section file. Principal Developers \u00b6 David A. Kopriva , Florida State University, USA Contributors \u00b6 The following people contributed major additions or modifications to HOHQMesh and are listed in alphabetical order: David A. Kopriva Joseph Schoonover","title":"Authors"},{"location":"authors/#authors","text":"HOHQMesh's development is coordinated by David A. Kopriva, who is the principal developer and main contributor. In addition, there are contributors who have provided substantial additions or modifications. Together, these two groups form authors as mentioned in the the License section file.","title":"Authors"},{"location":"authors/#principal-developers","text":"David A. Kopriva , Florida State University, USA","title":"Principal Developers"},{"location":"authors/#contributors","text":"The following people contributed major additions or modifications to HOHQMesh and are listed in alphabetical order: David A. Kopriva Joseph Schoonover","title":"Contributors"},{"location":"building-the-documentation/","text":"Building the Documentation \u00b6 To generate the HOHQMesh documentation, you need a reasonably recent version of Python 3 and the mkdocs-material package. The latter can be installed via pip using pip install mkdocs-material which will also install all relevant dependencies. Note that on some systems (e.g., Ubuntu 20.04), mkdocs-material requires a minimum version of the dependent Jinja2 package that has a known bug. Please make sure that you have at least Jinja2 2.11 installed by checking the output of pip show Jinja2 If it is too old, you can upgrade Jinja2 by running pip install Jinja2 --upgrade For local viewing, change to the directory where the mkdocs.yml file is located. Then execute ./preparedocs to prepare some Markdown files that are located out of the main documentation directory docs . Then, you have two options: To view the documentation via the built-in webserver, execute mkdocs serve and follow the link printed to the terminal to open the documentation in your browser. To generate a static set of files on disk, run mkdocs build --no-directory-urls and open the file site/index.html in your browser. If, for some reason, you would like to download all images used in the documentation that are hosted on GitHub, you can automate this process by executing ./download_github_images This will download the GitHub-hosted images and save them in the current working directory. Note that the script will only consider images that have been added to it manually.","title":"Building the Documentation"},{"location":"building-the-documentation/#building-the-documentation","text":"To generate the HOHQMesh documentation, you need a reasonably recent version of Python 3 and the mkdocs-material package. The latter can be installed via pip using pip install mkdocs-material which will also install all relevant dependencies. Note that on some systems (e.g., Ubuntu 20.04), mkdocs-material requires a minimum version of the dependent Jinja2 package that has a known bug. Please make sure that you have at least Jinja2 2.11 installed by checking the output of pip show Jinja2 If it is too old, you can upgrade Jinja2 by running pip install Jinja2 --upgrade For local viewing, change to the directory where the mkdocs.yml file is located. Then execute ./preparedocs to prepare some Markdown files that are located out of the main documentation directory docs . Then, you have two options: To view the documentation via the built-in webserver, execute mkdocs serve and follow the link printed to the terminal to open the documentation in your browser. To generate a static set of files on disk, run mkdocs build --no-directory-urls and open the file site/index.html in your browser. If, for some reason, you would like to download all images used in the documentation that are hosted on GitHub, you can automate this process by executing ./download_github_images This will download the GitHub-hosted images and save them in the current working directory. Note that the script will only consider images that have been added to it manually.","title":"Building the Documentation"},{"location":"compiling-and-running-hohqmesh/","text":"Compiling and Running HOHQMesh \u00b6 Compiling the Mesher \u00b6 HOHQMesh is currently being distributed on gitHub. In that repository is a makefile, plus source, documentation (which contains this document) and a directory of examples. HOHQMesh is written in fortran90. It is known to compile and run with gfortran on Mac/Linux/Windows. Let us know if there are issues with other compilers. Or more recent versions of those. The mesher has one dependency, FTObjectLibrary, which supplies the container classes and exception classes. It is also available on gitHub under a project of that name. The makefile is for gmake. Use it to compile the mesher. To build, edit the Makefile file as indicated in the header and move to ones favorite directory. Type make That will build HOHQMesh. Running the Mesher \u00b6 To run the tests, type ./HOHQMesh -test -path <pathToBenchmarks> where <pathToBenchmarks> is the path to the HOHQMesh directory. To mesh a control file, type ./HOHQMesh -f <pathToControlFile> For example, to mesh the GingerbreadMan model in the Examples directory, type ./HOHQMesh -f Examples/2D/GingerbreadMan/GingerbreadMan.control The mesh and plot files will be created relative to the directory of the executable. For the moment, until things get really robust, diagnostic information can be printed as the program executes. Three more compiler flags are also defined: -version Gives the version number of the code -help Does nothing at the moment. Sorry. RTM. -verbose Determines whether progress messages are printed or not. Use these as usual, e.g. ./HOHQMesh -verbose -f Examples/2D/GingerbreadMan/GingerbreadMan.control","title":"Compiling and Running HOHQMesh"},{"location":"compiling-and-running-hohqmesh/#compiling-and-running-hohqmesh","text":"","title":"Compiling and Running HOHQMesh"},{"location":"compiling-and-running-hohqmesh/#compiling-the-mesher","text":"HOHQMesh is currently being distributed on gitHub. In that repository is a makefile, plus source, documentation (which contains this document) and a directory of examples. HOHQMesh is written in fortran90. It is known to compile and run with gfortran on Mac/Linux/Windows. Let us know if there are issues with other compilers. Or more recent versions of those. The mesher has one dependency, FTObjectLibrary, which supplies the container classes and exception classes. It is also available on gitHub under a project of that name. The makefile is for gmake. Use it to compile the mesher. To build, edit the Makefile file as indicated in the header and move to ones favorite directory. Type make That will build HOHQMesh.","title":"Compiling the Mesher"},{"location":"compiling-and-running-hohqmesh/#running-the-mesher","text":"To run the tests, type ./HOHQMesh -test -path <pathToBenchmarks> where <pathToBenchmarks> is the path to the HOHQMesh directory. To mesh a control file, type ./HOHQMesh -f <pathToControlFile> For example, to mesh the GingerbreadMan model in the Examples directory, type ./HOHQMesh -f Examples/2D/GingerbreadMan/GingerbreadMan.control The mesh and plot files will be created relative to the directory of the executable. For the moment, until things get really robust, diagnostic information can be printed as the program executes. Three more compiler flags are also defined: -version Gives the version number of the code -help Does nothing at the moment. Sorry. RTM. -verbose Determines whether progress messages are printed or not. Use these as usual, e.g. ./HOHQMesh -verbose -f Examples/2D/GingerbreadMan/GingerbreadMan.control","title":"Running the Mesher"},{"location":"examples/","text":"Examples \u00b6 HOHQMesh comes with 12 example control, mesh, and plot files for two-dimensional meshes found in the Examples/2D directory. These examples illustrate the use of the the control and model features, and the resulting meshes and plot files. Also included in the Examples directory is a control template: ControlTemplate.control, that can (like any of the examples) be modified at will. Name Description Outer Inner Chain Parametric Eqn Spline Line Arc Refinement Center Refinement Line AllFeatures A triangle with three holes 3 CavityRamp A cavity domain with a sloping ramp on the exit side Circles3 Three circles enclosed by a large circle 3 EllipseAndFourCircles Four circles enclosed by an ellipse 4 GingerbreadMan Geometry with lots of holes 6 Half Circle A half circle Indian Ocean Complex domain with islands and inlets 3 KT3Element Three element Karman-Treffitz airfoil 3 Lake Superior Complex domain with islands 2 NACA0012 Standard Airfoil geometry Pill Oblong domain with interior circles 3 SplineGeometry Free form domain defined as a spline Square Generation of a Cartesian mesh with no model There are also eight three dimensional examples that illustrate the different extrusion algorithms in the Examples/3D directory Name Description Algorithm Topography Box Extrusion of a square into a box. No Model SIMPLE_EXTRUSION BoxRotated Rotation of a square about the x-axis. No Model SIMPLE_ROTATION CavityRampExtruded Extrusion of the 2D CavityRamp SIMPLE_EXTRUSION HalfCircleExtruded Extrusion of the 2D HalfCircle SIMPLE_EXTRUSION HalfCircleRotated Rotation of the 2D half circle about the x-axis SIMPLE_ROTATION Pond Extrusion of a circle SIMPLE_EXTRUSION ScaledCylinder Sweeping of a circle with scale factor applied SWEEP_ALONG_CURVE Snake Sweeping of a circle along multiple axes SWEEP_ALONG_CURVE","title":"Pre-made Examples"},{"location":"examples/#examples","text":"HOHQMesh comes with 12 example control, mesh, and plot files for two-dimensional meshes found in the Examples/2D directory. These examples illustrate the use of the the control and model features, and the resulting meshes and plot files. Also included in the Examples directory is a control template: ControlTemplate.control, that can (like any of the examples) be modified at will. Name Description Outer Inner Chain Parametric Eqn Spline Line Arc Refinement Center Refinement Line AllFeatures A triangle with three holes 3 CavityRamp A cavity domain with a sloping ramp on the exit side Circles3 Three circles enclosed by a large circle 3 EllipseAndFourCircles Four circles enclosed by an ellipse 4 GingerbreadMan Geometry with lots of holes 6 Half Circle A half circle Indian Ocean Complex domain with islands and inlets 3 KT3Element Three element Karman-Treffitz airfoil 3 Lake Superior Complex domain with islands 2 NACA0012 Standard Airfoil geometry Pill Oblong domain with interior circles 3 SplineGeometry Free form domain defined as a spline Square Generation of a Cartesian mesh with no model There are also eight three dimensional examples that illustrate the different extrusion algorithms in the Examples/3D directory Name Description Algorithm Topography Box Extrusion of a square into a box. No Model SIMPLE_EXTRUSION BoxRotated Rotation of a square about the x-axis. No Model SIMPLE_ROTATION CavityRampExtruded Extrusion of the 2D CavityRamp SIMPLE_EXTRUSION HalfCircleExtruded Extrusion of the 2D HalfCircle SIMPLE_EXTRUSION HalfCircleRotated Rotation of the 2D half circle about the x-axis SIMPLE_ROTATION Pond Extrusion of a circle SIMPLE_EXTRUSION ScaledCylinder Sweeping of a circle with scale factor applied SWEEP_ALONG_CURVE Snake Sweeping of a circle along multiple axes SWEEP_ALONG_CURVE","title":"Examples"},{"location":"how-hohqmesh-works/","text":"How HOHQMesh Works \u00b6 Introduction \u00b6 HOHQMesh is an automatic quad/hex mesh generator designed to be fully automatic. From the user's point of view, he/she creates a MODEL, which consists of (optionally) an outer boundary curve and any number of inner boundary curves. The user also includes CONTROL_INPUT to direct which files are created, the file formats, and three aspects of the mesh creation process: the background grid, which is the basic mesh size desired, the smoother, and manual refinement by way of REFINEMENT_CENTERs or REFINEMENT_LINES. The mesher then uses the model curves and control parameters to automatically refine near model features to generate a mesh. Basic 2D Meshing strategy \u00b6 The basic strategy for the 2D quadrilateral mesh generation is that devised by Robert Schneiders in \"Algorithms for Quadrilateral and Hexahedral Mesh Generation\". It appears to be unpublished but is available online. The basic 2D steps are: A uniform grid is laid down and a quadtree subdivision is performed until a size criterion is met. [MeshGeneratorMethods.f90/GenerateGridWithSizerAndType] The grid is made conforming by inserting templates for each possible non-conforming interface. There are 15 of these, plus rotations. [Templates.f90] Elements are created from the quads [MeshGeneratorMethods.f90/GenerateNodesAndElements] Exterior elements are marked in a \"cookie-cutter\" procedure and then removed. [MeshGeneratorMethods.f90/MarkExteriorElements] This gives a ragged boundary, which is smoothed. Boundary edges are then normally projected onto the boundary curves [MeshGeneratorMethods.f90/LocateEdgeImagesOnBoundaries], thereby creating boundary elements. [MeshGeneratorMethods.f90/GenerateBoundaryElements] A topology cleanup is performed: High valence node elements are combined (Currently only valence 7) [MeshCleaner.f90/PerformTopologyCleanup/ReduceNodeValences] and diamond elements are collapsed. [MeshCleaner.f90/PerformTopologyCleanup/RemoveDiamondElements]. Many more topology cleanup methods have been proposed in the literature and could be added at this stage. The mesh is smoothed using a Smoother. [MeshSmoother.f90] contains the base class for a smoother. The LaplaceSmoother subclass doesn't really work yet. The workhorse is the spring-dashpot in [SpringMeshSmoother.f90]. A final clean-up is performed [MeshCleaner.f90/PerformFinalMeshCleanup]. Bad elements are marked using a set of mesh quality analysis measures from the Verdict library: C. Simpson, C. D. Ernst, P. Knupp, P. P. P \u0301ebay, and D. C. Thompson. The Verdict Library Reference Manual. Sandia National Laboratories, April 2007.URL www.vtk.org/Wiki/images/6/6b/VerdictManual-revA.pdf . Info about them is written to the Stats file. Chevron elements are removed with a template. A final smoothing is done Plot (for quick viewing) and mesh files are written. 3D Mesh Generation \u00b6 Hex elements are created by extrusion of a 2D mesh. Three extrusions are possible: Simple Sweep: Sweep along a line in one of the three coordinate directions. [3DMeshController.f90/PerformSimpleMeshSweep] Simple Rotation: Rotate the 2D mesh through an angle about an axis. Sweep along a given curve. [SweeperClass.f90] Sweep can simply follow the curve [SweeperClass.f90/applyDefaultSweepTransform], which is fully accurate but can introduce twisting in the 3D mesh, or use a parallel transport algorithm [SweeperClass.f90/applyHansonSweepTransform] which eliminates the twist, but is only 2nd order accurate in following the sweep curve.","title":"How HOHQMesh Works"},{"location":"how-hohqmesh-works/#how-hohqmesh-works","text":"","title":"How HOHQMesh Works"},{"location":"how-hohqmesh-works/#introduction","text":"HOHQMesh is an automatic quad/hex mesh generator designed to be fully automatic. From the user's point of view, he/she creates a MODEL, which consists of (optionally) an outer boundary curve and any number of inner boundary curves. The user also includes CONTROL_INPUT to direct which files are created, the file formats, and three aspects of the mesh creation process: the background grid, which is the basic mesh size desired, the smoother, and manual refinement by way of REFINEMENT_CENTERs or REFINEMENT_LINES. The mesher then uses the model curves and control parameters to automatically refine near model features to generate a mesh.","title":"Introduction"},{"location":"how-hohqmesh-works/#basic-2d-meshing-strategy","text":"The basic strategy for the 2D quadrilateral mesh generation is that devised by Robert Schneiders in \"Algorithms for Quadrilateral and Hexahedral Mesh Generation\". It appears to be unpublished but is available online. The basic 2D steps are: A uniform grid is laid down and a quadtree subdivision is performed until a size criterion is met. [MeshGeneratorMethods.f90/GenerateGridWithSizerAndType] The grid is made conforming by inserting templates for each possible non-conforming interface. There are 15 of these, plus rotations. [Templates.f90] Elements are created from the quads [MeshGeneratorMethods.f90/GenerateNodesAndElements] Exterior elements are marked in a \"cookie-cutter\" procedure and then removed. [MeshGeneratorMethods.f90/MarkExteriorElements] This gives a ragged boundary, which is smoothed. Boundary edges are then normally projected onto the boundary curves [MeshGeneratorMethods.f90/LocateEdgeImagesOnBoundaries], thereby creating boundary elements. [MeshGeneratorMethods.f90/GenerateBoundaryElements] A topology cleanup is performed: High valence node elements are combined (Currently only valence 7) [MeshCleaner.f90/PerformTopologyCleanup/ReduceNodeValences] and diamond elements are collapsed. [MeshCleaner.f90/PerformTopologyCleanup/RemoveDiamondElements]. Many more topology cleanup methods have been proposed in the literature and could be added at this stage. The mesh is smoothed using a Smoother. [MeshSmoother.f90] contains the base class for a smoother. The LaplaceSmoother subclass doesn't really work yet. The workhorse is the spring-dashpot in [SpringMeshSmoother.f90]. A final clean-up is performed [MeshCleaner.f90/PerformFinalMeshCleanup]. Bad elements are marked using a set of mesh quality analysis measures from the Verdict library: C. Simpson, C. D. Ernst, P. Knupp, P. P. P \u0301ebay, and D. C. Thompson. The Verdict Library Reference Manual. Sandia National Laboratories, April 2007.URL www.vtk.org/Wiki/images/6/6b/VerdictManual-revA.pdf . Info about them is written to the Stats file. Chevron elements are removed with a template. A final smoothing is done Plot (for quick viewing) and mesh files are written.","title":"Basic 2D Meshing strategy"},{"location":"how-hohqmesh-works/#3d-mesh-generation","text":"Hex elements are created by extrusion of a 2D mesh. Three extrusions are possible: Simple Sweep: Sweep along a line in one of the three coordinate directions. [3DMeshController.f90/PerformSimpleMeshSweep] Simple Rotation: Rotate the 2D mesh through an angle about an axis. Sweep along a given curve. [SweeperClass.f90] Sweep can simply follow the curve [SweeperClass.f90/applyDefaultSweepTransform], which is fully accurate but can introduce twisting in the 3D mesh, or use a parallel transport algorithm [SweeperClass.f90/applyHansonSweepTransform] which eliminates the twist, but is only 2nd order accurate in following the sweep curve.","title":"3D Mesh Generation"},{"location":"introduction/","text":"Introduction \u00b6 Multidomain spectral methods, of which spectral element methods (SEMs) are a subclass, were introduced by Patera (for elliptic and parabolic equations) and by Kopriva (for hyperbolic systems) to increase the efficiency of spectral methods and to apply them to complex geometries. Although somewhat controversial at the time -- questions were raised whether it was wise to not use the highest order polynomial possible for a given number of degrees of freedom -- the methods have become so commonly used within the community that the updated book by Canuto et al. is subtitled \u201cFundamentals in Single Domains.\u201d The features of spectral element methods are now well-established. Like low order finite element methods, they can be applied to general geometries, but have exponential convergence in the polynomial order. Discontinuous Galerkin (DGSEM) versions applied to hyperbolic problems have exponentially low dissipation and dispersion errors, making them well suited for wave propagation problems. They are also especially suitable when material discontinuities are present. Approximations exist for high order quad/hex and tri/tet elements. Numerous examples of the flexibility and the power of spectral element methods can be found in Canuto et al.\u2019s third volume subtitled \u201cEvolution to Complex Geometries\u201d. Textbooks on the subject now exist, such as those by Deville, Fischer and Mund, Sherwin and Karniadakis , Hesthaven and Warburton, and Kopriva. What some are now calling \u201cclassical\u201d spectral element methods use tensor product bases on quadrilateral or hexahedral meshes. These bases lead to very efficient implementations and have high order quadratures that can be used to approximate the integrals found in weak forms of the equations. The methods are being used in a wide variety of fields including fluid dynamics, electromagnetics, geophysics, and fluid-structure interaction problems, just to name a few. Unfortunately, meshes for quad/hex elements are considered to be difficult to generate even for low order finite element approximations. This has lead to the development of triangular/tetrahedral spectral element bases. These methods can adapt the meshes generated by virtually all mesh generation packages today in two and three space dimensions. What one gives up in trade is the efficiency of the derivative evaluations, the Gauss quadratures, and meshes well-suited for boundary layer computations. Spectral Element Grid Generation \u00b6 The advantages not withstanding, a major frustration in - and impediment to - the application of spectral element methods has been the lack of appropriate general purpose mesh generation software. A survey of the literature, practitioners, and user manuals for available spectral element software packages such as SemTex, SEM2DPack, or Nekton, highlights these difficulties. Blackburn's SemTex page http://users.monash.edu.au/~bburn/semtex.html notes that \u201cMesh generation can be a significant hurdle to new users\u201d and includes \u201ca number of example meshes ... (most of which were generated by hand).\u201d SEM2DPack's manual says it \u201ccan only generate a structured mesh for a single quadrilateral domain, possibly with curved sub-horizontal boundaries and curved sub-horizontal layer interfaces.\u201d Sherwin and Peiro's comment: \u201cThe ability to construct suitable computational meshes is currently a significant limiting factor in the development of compact high-order algorithms in very complex geometries\u201d still holds today. Canuto et al. do not even broach the subject. Simply put, and avoiding the common colloquialism, the state of the art in spectral element grid generation has been dismal. One finds that spectral element meshes are either generated \u201cby hand\u201d, by special purpose mesh generators, or by low order finite element packages. Examples of hand generated meshes can be found in the textbooks listed above, for instance. SEM2DPack interfaces with the low order finite element mesh generator EMC2. The Nekton and SemTex packages interface with the finite element package GMSH. But the situation is particularly difficult for ``classical'' quad and hex element codes since even low order finite element mesh generators for these elements are hard to find. A consequence is that one even finds meshes in the literature that are simple quad/hex decompositions of low order triangular/tetrahedral meshes. The meshes that practitioners generate differ greatly from those generated by finite element mesh generators. The reason is not just a matter of the tedium associated with the process. Spectral element approximations encourage the use of larger elements with curved boundaries approximated at high order. Meshes generated by hand or with simple templates tend to have fewer and larger elements. Meshes generated by finite element packages designed for low order elements generate huge numbers of small elements and do not exploit the efficiency of high order spectral element approximations. The use of standard generators can lead one to use a high order method, yet approximate curved boundaries as segments of straight lines. Commercial mesh generators that generate \u201chigher order elements\u201d, e.g. PATRAN, GMSH or Gambit, do exist, but high order usually means third order, tops. ICEM-HEXA will guarantee quad/hex spectral element type meshes only for block structured meshes. The costs of commercial packages, however, are so far above the budgets provided by the typical NSF grant or mathematics department and so aren\u2019t an option even if they could generate spectral element meshes. HOHQMesh \u00b6 For these reasons we have developed the High Order Hex-Quad Mesh (HOHQMesh) package to automatically generate all-quadrilateral meshes with high order boundary information to be used in spectral element computations. It also can take such two dimensional meshes and extrude them in the normal direction to general all hex meshes for simple extrusion type geometries. Example Meshes \u00b6 Before going into details, we show some meshes that have been generated by HOHQMesh. Control files for generating these meshes can be found in the Examples directory. Some of the meshes show internal spectral element degrees of freedom and the fully accurate boundary representations. Others show only the quad or hex shape of the elements as given in the plot file generated by the program. The first example is a full spectral element mesh for three circles within an outer circle. HOHQMesh is fully automatic and sizes the elements according to the geometry. Fig. 1. Sixth order spectral element mesh of three circles within a circle (_Examples/2D/Circles3_) The second example example shows that general curves can be used to define the boundaries. This time, a set of points and a spline are use to define the outer boundary. Fig. 2. Eighth order spectral element mesh of a domain bounded by a spline curve (_Examples/2D/Spline_) HOHQMesh has templates to automatically mesh around sharp corners. Fig. 3. Spectral element mesh of a domain with sharp corners (_Examples/2D/CavityRamp_) This makes it possible to mesh airfoil type geometries. Fig. 4. Mesh of a NACA0012 airfoil (_Examples/2D/NACA0012_) Fig. 5. Mesh for a three element Karman-Treffiz airfoil (_Examples/2D/KT3Element_) Local refinement can be added manually, either at a point or along a line. Fig. 6. Mesh showing manual refinement along a line and at a point (_Examples/2D/AllFeatures_) Truly complex geometries can be meshed, as shown in the following coastline models. Refinement around features is automatic. Fig. 7. The Indian Ocean (_Examples/2D/IndianOcean_) Fig. 8. Lake Superior with specral element nodes shown (_Examples/2D/LakeSuperior_) Finally, hex meshes can also be created by sweeping a quad mesh. The simplest way is to extrude a two-dimensional mesh in one of the coordinate directions. Fig. 9. Simple extrusion of the mesh in Fig. 3 (_Examples/3D/CavityRampExtruded_) Or the mesh can be rotated along a coordinate axis through a specified angle, Fig. 10. Simple rotation of the mesh in Fig. 3 More sophisticated extrusions can be created by sweeping along a curve, Fig. 11. Hex mesh generated by sweeping along a curve (_Examples/3D/Snake_) Finally, swept meshes can also be scaled along the curve. Fig. 12. Hex mesh generated by sweeping and scaling along a curve All told, the geometries that can be meshed can be quite general ( Examples/2D/GingerbreadMan ).","title":"Introduction"},{"location":"introduction/#introduction","text":"Multidomain spectral methods, of which spectral element methods (SEMs) are a subclass, were introduced by Patera (for elliptic and parabolic equations) and by Kopriva (for hyperbolic systems) to increase the efficiency of spectral methods and to apply them to complex geometries. Although somewhat controversial at the time -- questions were raised whether it was wise to not use the highest order polynomial possible for a given number of degrees of freedom -- the methods have become so commonly used within the community that the updated book by Canuto et al. is subtitled \u201cFundamentals in Single Domains.\u201d The features of spectral element methods are now well-established. Like low order finite element methods, they can be applied to general geometries, but have exponential convergence in the polynomial order. Discontinuous Galerkin (DGSEM) versions applied to hyperbolic problems have exponentially low dissipation and dispersion errors, making them well suited for wave propagation problems. They are also especially suitable when material discontinuities are present. Approximations exist for high order quad/hex and tri/tet elements. Numerous examples of the flexibility and the power of spectral element methods can be found in Canuto et al.\u2019s third volume subtitled \u201cEvolution to Complex Geometries\u201d. Textbooks on the subject now exist, such as those by Deville, Fischer and Mund, Sherwin and Karniadakis , Hesthaven and Warburton, and Kopriva. What some are now calling \u201cclassical\u201d spectral element methods use tensor product bases on quadrilateral or hexahedral meshes. These bases lead to very efficient implementations and have high order quadratures that can be used to approximate the integrals found in weak forms of the equations. The methods are being used in a wide variety of fields including fluid dynamics, electromagnetics, geophysics, and fluid-structure interaction problems, just to name a few. Unfortunately, meshes for quad/hex elements are considered to be difficult to generate even for low order finite element approximations. This has lead to the development of triangular/tetrahedral spectral element bases. These methods can adapt the meshes generated by virtually all mesh generation packages today in two and three space dimensions. What one gives up in trade is the efficiency of the derivative evaluations, the Gauss quadratures, and meshes well-suited for boundary layer computations.","title":"Introduction"},{"location":"introduction/#spectral-element-grid-generation","text":"The advantages not withstanding, a major frustration in - and impediment to - the application of spectral element methods has been the lack of appropriate general purpose mesh generation software. A survey of the literature, practitioners, and user manuals for available spectral element software packages such as SemTex, SEM2DPack, or Nekton, highlights these difficulties. Blackburn's SemTex page http://users.monash.edu.au/~bburn/semtex.html notes that \u201cMesh generation can be a significant hurdle to new users\u201d and includes \u201ca number of example meshes ... (most of which were generated by hand).\u201d SEM2DPack's manual says it \u201ccan only generate a structured mesh for a single quadrilateral domain, possibly with curved sub-horizontal boundaries and curved sub-horizontal layer interfaces.\u201d Sherwin and Peiro's comment: \u201cThe ability to construct suitable computational meshes is currently a significant limiting factor in the development of compact high-order algorithms in very complex geometries\u201d still holds today. Canuto et al. do not even broach the subject. Simply put, and avoiding the common colloquialism, the state of the art in spectral element grid generation has been dismal. One finds that spectral element meshes are either generated \u201cby hand\u201d, by special purpose mesh generators, or by low order finite element packages. Examples of hand generated meshes can be found in the textbooks listed above, for instance. SEM2DPack interfaces with the low order finite element mesh generator EMC2. The Nekton and SemTex packages interface with the finite element package GMSH. But the situation is particularly difficult for ``classical'' quad and hex element codes since even low order finite element mesh generators for these elements are hard to find. A consequence is that one even finds meshes in the literature that are simple quad/hex decompositions of low order triangular/tetrahedral meshes. The meshes that practitioners generate differ greatly from those generated by finite element mesh generators. The reason is not just a matter of the tedium associated with the process. Spectral element approximations encourage the use of larger elements with curved boundaries approximated at high order. Meshes generated by hand or with simple templates tend to have fewer and larger elements. Meshes generated by finite element packages designed for low order elements generate huge numbers of small elements and do not exploit the efficiency of high order spectral element approximations. The use of standard generators can lead one to use a high order method, yet approximate curved boundaries as segments of straight lines. Commercial mesh generators that generate \u201chigher order elements\u201d, e.g. PATRAN, GMSH or Gambit, do exist, but high order usually means third order, tops. ICEM-HEXA will guarantee quad/hex spectral element type meshes only for block structured meshes. The costs of commercial packages, however, are so far above the budgets provided by the typical NSF grant or mathematics department and so aren\u2019t an option even if they could generate spectral element meshes.","title":"Spectral Element Grid Generation"},{"location":"introduction/#hohqmesh","text":"For these reasons we have developed the High Order Hex-Quad Mesh (HOHQMesh) package to automatically generate all-quadrilateral meshes with high order boundary information to be used in spectral element computations. It also can take such two dimensional meshes and extrude them in the normal direction to general all hex meshes for simple extrusion type geometries.","title":"HOHQMesh"},{"location":"introduction/#example-meshes","text":"Before going into details, we show some meshes that have been generated by HOHQMesh. Control files for generating these meshes can be found in the Examples directory. Some of the meshes show internal spectral element degrees of freedom and the fully accurate boundary representations. Others show only the quad or hex shape of the elements as given in the plot file generated by the program. The first example is a full spectral element mesh for three circles within an outer circle. HOHQMesh is fully automatic and sizes the elements according to the geometry. Fig. 1. Sixth order spectral element mesh of three circles within a circle (_Examples/2D/Circles3_) The second example example shows that general curves can be used to define the boundaries. This time, a set of points and a spline are use to define the outer boundary. Fig. 2. Eighth order spectral element mesh of a domain bounded by a spline curve (_Examples/2D/Spline_) HOHQMesh has templates to automatically mesh around sharp corners. Fig. 3. Spectral element mesh of a domain with sharp corners (_Examples/2D/CavityRamp_) This makes it possible to mesh airfoil type geometries. Fig. 4. Mesh of a NACA0012 airfoil (_Examples/2D/NACA0012_) Fig. 5. Mesh for a three element Karman-Treffiz airfoil (_Examples/2D/KT3Element_) Local refinement can be added manually, either at a point or along a line. Fig. 6. Mesh showing manual refinement along a line and at a point (_Examples/2D/AllFeatures_) Truly complex geometries can be meshed, as shown in the following coastline models. Refinement around features is automatic. Fig. 7. The Indian Ocean (_Examples/2D/IndianOcean_) Fig. 8. Lake Superior with specral element nodes shown (_Examples/2D/LakeSuperior_) Finally, hex meshes can also be created by sweeping a quad mesh. The simplest way is to extrude a two-dimensional mesh in one of the coordinate directions. Fig. 9. Simple extrusion of the mesh in Fig. 3 (_Examples/3D/CavityRampExtruded_) Or the mesh can be rotated along a coordinate axis through a specified angle, Fig. 10. Simple rotation of the mesh in Fig. 3 More sophisticated extrusions can be created by sweeping along a curve, Fig. 11. Hex mesh generated by sweeping along a curve (_Examples/3D/Snake_) Finally, swept meshes can also be scaled along the curve. Fig. 12. Hex mesh generated by sweeping and scaling along a curve All told, the geometries that can be meshed can be quite general ( Examples/2D/GingerbreadMan ).","title":"Example Meshes"},{"location":"license/","text":"MIT License Copyright (c) 2010-present David A. Kopriva and other contributors: Authors Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. HOHQMesh contains code that, to the best of our knowledge, has been released as public domain software: b3hs_hash_key_jenkins : originally by Rich Townsend, https://groups.google.com/forum/#!topic/comp.lang.fortran/RWoHZFt39ng, 2005 fmin : originally by George Elmer Forsythe, Michael A. Malcolm, Cleve B. Moler, Computer Methods for Mathematical Computations, 1977 spline : originally by George Elmer Forsythe, Michael A. Malcolm, Cleve B. Moler, Computer Methods for Mathematical Computations, 1977 seval : originally by George Elmer Forsythe, Michael A. Malcolm, Cleve B. Moler, Computer Methods for Mathematical Computations, 1977","title":"License"},{"location":"releasing-a-new-version/","text":"Releasing a New Version \u00b6 This document describes the necessary steps for creating a new HOHQMesh release. When following these guidelines, don't forget to replace 1.2.3 with the current release version of HOHQMesh, and 1.3.0 with the new release you are about to create. Note: All steps as described here are assumed to be performed in a clean clone of the main branch. Otherwise the creation of the release tarball will fail! Pre-release preparations \u00b6 Ensure that the current HOHQMesh commit on main has passed all tests on GitHub by verifying that there is a green checkmark behind the latest commit on https://github.com/trixi-framework/HOHQMesh/commits/main . Enter the HOHQMesh clone directory, switch to main , and pull the latest version from GitHub: cd HOHQMesh git checkout main git pull Ensure that the latest version of FTObjectLibrary is present in the Contrib directory by calling the bootstrap script: ./Utilities/bootstrap Get the latest HOHQMesh version tag by executing git tag --list 'v*' --sort -version:refname | head -n1 This will yield something like v1.2.3 , where 1.2.3 is the version number and the v prefix indicates that this is really a version tag. Compare this with the latest release on GitHub. If the version numbers of the latest tag and the latest release differ, investigate (and possibly fix it) before proceeding. Determine which kind of version increment is necessary based on the changes since the last release. We use semantic versioning , which states Given a version number MAJOR.MINOR.PATCH, increment the: MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards compatible manner, and PATCH version when you make backwards compatible bug fixes. To see all the changes since the last release, you can use GitHub's compare functionality by navigating to the following address, adjusting the version tag appropriately: https://github.com/trixi-framework/HOHQMesh/compare/v1.2.3...main If you prefer to work to work locally in a console, you can execute git diff v1.2.3 Let's say that the changes require a minor version increment, thus the new release version following 1.2.3 would be 1.3.0 . Release creation \u00b6 Increment the version number in Source/HOHQMeshMain.f90 . The current version in the file should be something like 1.2.4-pre , indicating that the main branch is in a pre-release state (as it should be during development). Change the pre-release version string to the new version number you determined above, e.g., to 1.3.0 : CHARACTER ( LEN =* ), PARAMETER :: version = \"1.3.0\" Commit and push to main (make sure to use your version number!): git add Source/HOHQMeshMain.f90 git commit -m 'Increment version to v1.3.0' git push Ensure that you did not accidentally break anything and verify that there is a green checkmark behind the latest commit on https://github.com/trixi-framework/HOHQMesh/commits/main. Create a new release tarball by executing ./Utilities/createrelease 1 .3.0 where 1.3.0 again refers to the new release version ( without the v prefix!). This will result in a new file HOHQMesh-v1.3.0.tar.gz in the current directory. Test the new release by executing FC = gfortran ./Utilities/testrelease HOHQMesh-v1.3.0.tar.gz Make sure you change the Fortran compiler executable to one suitable for your system by modifying the FC environment variable accordingly. If it fails, do not just change the files in your current directory! Instead, figure out why the tests fail, fix them, commit and push the changes and start over. Create a new annotated Git tag and push it to GitHub (make sure to include the v prefix and to use your version number both for the tag and the message!): git tag -a v1.3.0 -m \"HOHQMesh v1.3.0\" git push --tags Navigate to https://github.com/trixi-framework/HOHQMesh/releases/new to start creating a new release. Enter v1.3.0 as the Tag version , which should find the Git tag you just created. Use HOHQMesh v1.3.0 as the Release title . Feel free to add more information about this release in the description field (optional). Attach the file you just created to the new release by dragging and dropping the tarball HOHQMesh-v1.3.0.tar.gz in the gray area below the release description. Click Publish release . Post-release actions \u00b6 Increment the version number in Source/HOHQMeshMain.f90 to a pre-release version to indicate that the current content of the main branch does not necessarily reflect the files of an existing, tagged release. The pre-release version is generated by incrementing the current patch version and appending -pre . For example, if you just created the release 1.3.0 , the next pre-release version would be 1.3.1-pre . Commit and push to main (make sure to use your version number!): git add Source/HOHQMeshMain.f90 git commit -m 'Set development version to v1.3.1-pre' git push Consider updating the Spack package specifications .","title":"Releasing a New Version"},{"location":"releasing-a-new-version/#releasing-a-new-version","text":"This document describes the necessary steps for creating a new HOHQMesh release. When following these guidelines, don't forget to replace 1.2.3 with the current release version of HOHQMesh, and 1.3.0 with the new release you are about to create. Note: All steps as described here are assumed to be performed in a clean clone of the main branch. Otherwise the creation of the release tarball will fail!","title":"Releasing a New Version"},{"location":"releasing-a-new-version/#pre-release-preparations","text":"Ensure that the current HOHQMesh commit on main has passed all tests on GitHub by verifying that there is a green checkmark behind the latest commit on https://github.com/trixi-framework/HOHQMesh/commits/main . Enter the HOHQMesh clone directory, switch to main , and pull the latest version from GitHub: cd HOHQMesh git checkout main git pull Ensure that the latest version of FTObjectLibrary is present in the Contrib directory by calling the bootstrap script: ./Utilities/bootstrap Get the latest HOHQMesh version tag by executing git tag --list 'v*' --sort -version:refname | head -n1 This will yield something like v1.2.3 , where 1.2.3 is the version number and the v prefix indicates that this is really a version tag. Compare this with the latest release on GitHub. If the version numbers of the latest tag and the latest release differ, investigate (and possibly fix it) before proceeding. Determine which kind of version increment is necessary based on the changes since the last release. We use semantic versioning , which states Given a version number MAJOR.MINOR.PATCH, increment the: MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards compatible manner, and PATCH version when you make backwards compatible bug fixes. To see all the changes since the last release, you can use GitHub's compare functionality by navigating to the following address, adjusting the version tag appropriately: https://github.com/trixi-framework/HOHQMesh/compare/v1.2.3...main If you prefer to work to work locally in a console, you can execute git diff v1.2.3 Let's say that the changes require a minor version increment, thus the new release version following 1.2.3 would be 1.3.0 .","title":"Pre-release preparations"},{"location":"releasing-a-new-version/#release-creation","text":"Increment the version number in Source/HOHQMeshMain.f90 . The current version in the file should be something like 1.2.4-pre , indicating that the main branch is in a pre-release state (as it should be during development). Change the pre-release version string to the new version number you determined above, e.g., to 1.3.0 : CHARACTER ( LEN =* ), PARAMETER :: version = \"1.3.0\" Commit and push to main (make sure to use your version number!): git add Source/HOHQMeshMain.f90 git commit -m 'Increment version to v1.3.0' git push Ensure that you did not accidentally break anything and verify that there is a green checkmark behind the latest commit on https://github.com/trixi-framework/HOHQMesh/commits/main. Create a new release tarball by executing ./Utilities/createrelease 1 .3.0 where 1.3.0 again refers to the new release version ( without the v prefix!). This will result in a new file HOHQMesh-v1.3.0.tar.gz in the current directory. Test the new release by executing FC = gfortran ./Utilities/testrelease HOHQMesh-v1.3.0.tar.gz Make sure you change the Fortran compiler executable to one suitable for your system by modifying the FC environment variable accordingly. If it fails, do not just change the files in your current directory! Instead, figure out why the tests fail, fix them, commit and push the changes and start over. Create a new annotated Git tag and push it to GitHub (make sure to include the v prefix and to use your version number both for the tag and the message!): git tag -a v1.3.0 -m \"HOHQMesh v1.3.0\" git push --tags Navigate to https://github.com/trixi-framework/HOHQMesh/releases/new to start creating a new release. Enter v1.3.0 as the Tag version , which should find the Git tag you just created. Use HOHQMesh v1.3.0 as the Release title . Feel free to add more information about this release in the description field (optional). Attach the file you just created to the new release by dragging and dropping the tarball HOHQMesh-v1.3.0.tar.gz in the gray area below the release description. Click Publish release .","title":"Release creation"},{"location":"releasing-a-new-version/#post-release-actions","text":"Increment the version number in Source/HOHQMeshMain.f90 to a pre-release version to indicate that the current content of the main branch does not necessarily reflect the files of an existing, tagged release. The pre-release version is generated by incrementing the current patch version and appending -pre . For example, if you just created the release 1.3.0 , the next pre-release version would be 1.3.1-pre . Commit and push to main (make sure to use your version number!): git add Source/HOHQMeshMain.f90 git commit -m 'Set development version to v1.3.1-pre' git push Consider updating the Spack package specifications .","title":"Post-release actions"},{"location":"the-control-file/","text":"The Control File \u00b6 The MODEL and the CONTROL_INPUT blocks described above are put into a single file called the control file , which is finished with a \\end{FILE} command. An example of a full control file that meshes a model with a circular outer boundary and two inner circular boundaries, and writes out a plot file with spectral element resolution, is shown below. There is also a template control file in the Examples directory. Just some notes: Blocks do not have to be specified in any order (e.g. the MODEL could come first before the CONTROL_INPUT . INNER_BOUNDARIES could come before OUTER_BOUNDARY . Blocks must be defined withing their appropriate block however, e.g. OUTER_BOUNDARY can only be defined in a MODEL block. Keywords within a block can be specified in any order. The only ordering that is important is that within a CHAIN , the curves must be specified in order, counter-clockwise. Spaces in keywords are significant, but not in any other contexts. For instance equals signs are aligned only for visual formatting. Blank lines or lines starting with % are ignored. \\begin{CONTROL_INPUT} \\begin{RUN_PARAMETERS} mesh file name = Circles3Mesh.mesh plot file name = Circles3Plot.tec statistics file name = Circles3Stats.txt mesh file format = ISM polynomial order = 6 plot file format = sem \\end{RUN_PARAMETERS} \\begin{BACKGROUND_GRID} background grid size = [4.0,4.0] \\end{BACKGROUND_GRID} \\begin{SPRING_SMOOTHER} smoothing type = LinearAndCrossbarSpring number of iterations = 20 \\end{SPRING_SMOOTHER} \\end{CONTROL_INPUT} \\begin{MODEL} \\begin{OUTER_BOUNDARY} \\begin{PARAMETRIC_EQUATION_CURVE} name = outer xEqn = x(t) = 14.0*cos(2*pi*t) yEqn = y(t) = 14.0*sin(2*pi*t) zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{OUTER_BOUNDARY} \\begin{INNER_BOUNDARIES} \\begin{CHAIN} name = Boundary 1 \\begin{PARAMETRIC_EQUATION_CURVE} name = Circle1 xEqn = f(t) = -10.25 + 0.2*cos(2*pi*t) yEqn = f(t) = 3.0 + 0.2*sin(2*pi*t) zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{CHAIN} \\begin{CHAIN} name = Boundary 2 \\begin{PARAMETRIC_EQUATION_CURVE} name = Circle2 xEqn = f(t) = -5.1 + 1.0*cos(2*pi*t) yEqn = f(t) = 1.0*sin(2*pi*t) - 4.1 zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{CHAIN} \\begin{CHAIN} name = Boundary 3 \\begin{PARAMETRIC_EQUATION_CURVE} name = Circle3 xEqn = f(t) = -12.0 + 0.5*cos(2*pi*t) yEqn = f(t) = 0.5*sin(2*pi*t) - 0.5 zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{CHAIN} \\end{INNER_BOUNDARIES} \\end{MODEL} \\end{FILE}","title":"The Control File"},{"location":"the-control-file/#the-control-file","text":"The MODEL and the CONTROL_INPUT blocks described above are put into a single file called the control file , which is finished with a \\end{FILE} command. An example of a full control file that meshes a model with a circular outer boundary and two inner circular boundaries, and writes out a plot file with spectral element resolution, is shown below. There is also a template control file in the Examples directory. Just some notes: Blocks do not have to be specified in any order (e.g. the MODEL could come first before the CONTROL_INPUT . INNER_BOUNDARIES could come before OUTER_BOUNDARY . Blocks must be defined withing their appropriate block however, e.g. OUTER_BOUNDARY can only be defined in a MODEL block. Keywords within a block can be specified in any order. The only ordering that is important is that within a CHAIN , the curves must be specified in order, counter-clockwise. Spaces in keywords are significant, but not in any other contexts. For instance equals signs are aligned only for visual formatting. Blank lines or lines starting with % are ignored. \\begin{CONTROL_INPUT} \\begin{RUN_PARAMETERS} mesh file name = Circles3Mesh.mesh plot file name = Circles3Plot.tec statistics file name = Circles3Stats.txt mesh file format = ISM polynomial order = 6 plot file format = sem \\end{RUN_PARAMETERS} \\begin{BACKGROUND_GRID} background grid size = [4.0,4.0] \\end{BACKGROUND_GRID} \\begin{SPRING_SMOOTHER} smoothing type = LinearAndCrossbarSpring number of iterations = 20 \\end{SPRING_SMOOTHER} \\end{CONTROL_INPUT} \\begin{MODEL} \\begin{OUTER_BOUNDARY} \\begin{PARAMETRIC_EQUATION_CURVE} name = outer xEqn = x(t) = 14.0*cos(2*pi*t) yEqn = y(t) = 14.0*sin(2*pi*t) zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{OUTER_BOUNDARY} \\begin{INNER_BOUNDARIES} \\begin{CHAIN} name = Boundary 1 \\begin{PARAMETRIC_EQUATION_CURVE} name = Circle1 xEqn = f(t) = -10.25 + 0.2*cos(2*pi*t) yEqn = f(t) = 3.0 + 0.2*sin(2*pi*t) zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{CHAIN} \\begin{CHAIN} name = Boundary 2 \\begin{PARAMETRIC_EQUATION_CURVE} name = Circle2 xEqn = f(t) = -5.1 + 1.0*cos(2*pi*t) yEqn = f(t) = 1.0*sin(2*pi*t) - 4.1 zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{CHAIN} \\begin{CHAIN} name = Boundary 3 \\begin{PARAMETRIC_EQUATION_CURVE} name = Circle3 xEqn = f(t) = -12.0 + 0.5*cos(2*pi*t) yEqn = f(t) = 0.5*sin(2*pi*t) - 0.5 zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{CHAIN} \\end{INNER_BOUNDARIES} \\end{MODEL} \\end{FILE}","title":"The Control File"},{"location":"the-control-input/","text":"The Control Input \u00b6 The meshing of the model is controlled by the CONTROL_INPUT block of the input control file, which gives all of the commands needed to mesh the model. Actually, there are not a lot of commands at the moment, so that\u2019s not too bad. The control block is \\begin{CONTROL_INPUT} ... \\end{CONTROL_INPUT} Inside the control input block the RUN_PARAMETERS , BACKGROUND_GRID , SMOOTHER , and any number of REFINEMENT_CENTER s and REFINEMENT_LINE s are defined. The Run Parameters \u00b6 The RUN_PARAMETERS block defines the file information and the polynomial order at which the boundary curves will be defined in the mesh file. Three files can be output by the mesher. The first listed below is the actual mesh file. The second is a tecplot format file that can be used to visualize the mesh. The free programs VisIt or Paraview can be used to plot tecplot files. The final file (optional) is to report mesh statistics, like the distribution of largest angle, Jacobian, etc. See the \u201cVerdict Library Reference Manual\u201d by Stimpson et al. if you are interested to learn about the different shape quality measures. Include a unix style path to choose the directory for the results. The RUN_PARAMETERS block is: \\begin{RUN_PARAMETERS} mesh file name = MeshFileName.mesh plot file name = PlotName.tec stats file name = StatsName.txt mesh file format = ISM *OR* ISM-v2 *OR* ABAQUS polynomial order = 6 plot file format = skeleton *OR* sem \\end{RUN_PARAMETERS} The names can be anything, since they are simply text files. However the \u201c.tec\u201d extension on the plot file will help VisIt/Paraview know how to read it. If you don\u2019t want a file created, simply choose the name to be none . In the current version of HOHQMesh, there are three mesh file formats, \u201cISM\u201d which stands for \u201cImplementing Spectral Methods\u201d . This is the file format described in the book by David A. Kopriva. The other available formats are \u201cISM-v2\u201d, which provides the edge information needed by the approximations so that the edge generation algorithms in the appendix of the book are not needed, and \"ABAQUS\", which provides the corner nodes and element connectivity data in the specific Abaqus file format . See the corresponding sections in the Appendix of this manual on ISM-v2 and ABAQUS for a description of the additional information they provide. In the future, other file formats may be implemented, too. Finally, high order boundary information is conveyed by outputting an interpolant of the specified order. That information can be viewed using the \u201csem\u201d plot file format. The Background Grid \u00b6 The meshing algorithm starts with a uniform background grid. If an outer boundary is specified in the model, HOHQMesh will create this background grid using the extents of the outer boundary and the background grid size specified in the BACKGROUND_GRID block. If there is no outer boundary, then the background grid must be specified in the control input. The BACKGROUND_GRID block specifies the coordinates of the lower left corner of the grid, the grid size in each coordinate direction, and the number of grid cells in each direction: \\begin{BACKGROUND_GRID} x0 = [-10.0, -10.0, 0.0] dx = [2.0, 2.0, 0.0] N = [10,10,0] \\end{BACKGROUND_GRID} If there is no MODEL block, then the BACKGROUND_GRID block will define the Cartesian mesh that will be generated, with the lower left point located at x0 , grid spacing dx , and N elements in each direction. For now, the z components must be zero so that the grid is in the x-y plane. The example above creates a uniform background grid with lower left corner at (-10,10) and upper right corner at (10,10). Alternatively, if there is an outer boundary curve, you want to specify the background grid size and let HOHQMesh compute the rest of the parameters: \\begin{BACKGROUND_GRID} background grid size = [2.0,2.0,0.0] \\end{BACKGROUND_GRID} This is the equivalent of dx in the previous incarnation. Note : In general you want to choose the grid size to be the same in each direction for the algorithms that make the mesh conforming to work properly. They can differ if a Cartesian mesh is being generated. The Smoother \u00b6 It is generally necessary to smooth the mesh after it is generated. Smoothing is done by the Smoother. The SPRING_SMOOTHER uses a spring-dashpot model and time relaxation to smooth the mesh. There are two spring topologies \u201cLinearSpring\u201d and \u201cLinearAndCrossbarSpring\u201d. The first only has springs between the nodes along the edges. The latter also puts springs along the diagonals of an element. The latter is preferred. The springs have a spring constant associated with them and a dashpot with a damping coefficient. The nodes have mass. The linear ODE system that describes the motion of the nodes is integrated with a forward Euler (Explicit!) approximation for which a time step and number of time steps are given. The SPRING_SMOOTHER block, if one is used (Recommended!) is \\begin{SPRING_SMOOTHER} smoothing = ON **or** OFF (Optional) smoothing type = LinearAndCrossbarSpring **or** LinearSpring spring constant = 1.0 (Optional) mass = 1.0 (Optional) rest length = 0.0 (Optional) damping coefficient = 5.0 (Optional) number of iterations = 20 time step = 0.1 (Optional) \\end{SPRING_SMOOTHER} Just leave out any of the optional parameters if you want the default values to be used. The default values should be sufficient, but the additional flexibility might be useful on occasion. (The architecture is designed for developers to add different (better!) smoothers, and hence the name \"SPRING_SMOOTHER\".) Refinement Regions \u00b6 Fig. 15. Two refinement centers and a refinement line Manual scaling of the mesh size can be performed by including any combination of Refinement Centers Refinement Lines Refinement Centers \u00b6 It is possible to ask HOHQMesh to locally refine the mesh at particular locations. This is done with a REFINEMENT_CENTER placed as desired. Two types of centers are available. One is \u201csmooth\u201d, which refines near a specified point and gradually de-refines towards the neighboring mesh size. The other is \u201csharp\u201d, which keeps the refined size in the neighborhood of the center. The desired mesh size and the size of the center are also parameters. An example of a refinement center is \\begin{REFINEMENT_CENTER} type = smooth **or** sharp x0 = [1.0,1.0,0.0] h = 0.20 w = 0.5 \\end{REFINEMENT_CENTER} This will place a center at (1,1,0) with mesh size of 0.2 over a circular region of radius 0.5 . Any number of RefinementCenters can be included. The order in which they are defined is not important. Refinement Lines \u00b6 The mesh can also be refined along a line using a REFINEMENT_LINE . Like the centers, there are two types, \u201csmooth\u201d and \u201csharp\u201d. To refine along a line, include a block of the form \\begin{REFINEMENT_LINE} type = smooth **or** sharp x0 = [-3.5,-3.5,0.0] x1 = [3.0,3.0,0.0] h = 0.20 w = 0.5 \\end{REFINEMENT_LINE} Here, x0 and x1 are the starting and ending points of the line, h is the desired mesh size and w tells how far out from the line the refinement extends. An example of center and line refinements can be seen in Fig. 15. Refinement Region Definition \u00b6 Refinement regions are defined within a REFINEMENT_REGIONS block, e.g. \\begin{REFINEMENT_REGIONS} \\begin{REFINEMENT_LINE} type = nonsmooth x0 = [-3.0,-3.0,0.0] x1 = [3.0,3.0,0.0] h = 0.3 w = 0.3 \\end{REFINEMENT_LINE} \\begin{REFINEMENT_CENTER} type = smooth x0 = [3.0,-3.0,0.0] h = 0.1 w = 0.3 \\end{REFINEMENT_CENTER} \\end{REFINEMENT_REGIONS} The ordering of the blocks within the REFINEMENT_REGIONS block is arbitrary.","title":"The Control Input"},{"location":"the-control-input/#the-control-input","text":"The meshing of the model is controlled by the CONTROL_INPUT block of the input control file, which gives all of the commands needed to mesh the model. Actually, there are not a lot of commands at the moment, so that\u2019s not too bad. The control block is \\begin{CONTROL_INPUT} ... \\end{CONTROL_INPUT} Inside the control input block the RUN_PARAMETERS , BACKGROUND_GRID , SMOOTHER , and any number of REFINEMENT_CENTER s and REFINEMENT_LINE s are defined.","title":"The Control Input"},{"location":"the-control-input/#the-run-parameters","text":"The RUN_PARAMETERS block defines the file information and the polynomial order at which the boundary curves will be defined in the mesh file. Three files can be output by the mesher. The first listed below is the actual mesh file. The second is a tecplot format file that can be used to visualize the mesh. The free programs VisIt or Paraview can be used to plot tecplot files. The final file (optional) is to report mesh statistics, like the distribution of largest angle, Jacobian, etc. See the \u201cVerdict Library Reference Manual\u201d by Stimpson et al. if you are interested to learn about the different shape quality measures. Include a unix style path to choose the directory for the results. The RUN_PARAMETERS block is: \\begin{RUN_PARAMETERS} mesh file name = MeshFileName.mesh plot file name = PlotName.tec stats file name = StatsName.txt mesh file format = ISM *OR* ISM-v2 *OR* ABAQUS polynomial order = 6 plot file format = skeleton *OR* sem \\end{RUN_PARAMETERS} The names can be anything, since they are simply text files. However the \u201c.tec\u201d extension on the plot file will help VisIt/Paraview know how to read it. If you don\u2019t want a file created, simply choose the name to be none . In the current version of HOHQMesh, there are three mesh file formats, \u201cISM\u201d which stands for \u201cImplementing Spectral Methods\u201d . This is the file format described in the book by David A. Kopriva. The other available formats are \u201cISM-v2\u201d, which provides the edge information needed by the approximations so that the edge generation algorithms in the appendix of the book are not needed, and \"ABAQUS\", which provides the corner nodes and element connectivity data in the specific Abaqus file format . See the corresponding sections in the Appendix of this manual on ISM-v2 and ABAQUS for a description of the additional information they provide. In the future, other file formats may be implemented, too. Finally, high order boundary information is conveyed by outputting an interpolant of the specified order. That information can be viewed using the \u201csem\u201d plot file format.","title":"The Run Parameters"},{"location":"the-control-input/#the-background-grid","text":"The meshing algorithm starts with a uniform background grid. If an outer boundary is specified in the model, HOHQMesh will create this background grid using the extents of the outer boundary and the background grid size specified in the BACKGROUND_GRID block. If there is no outer boundary, then the background grid must be specified in the control input. The BACKGROUND_GRID block specifies the coordinates of the lower left corner of the grid, the grid size in each coordinate direction, and the number of grid cells in each direction: \\begin{BACKGROUND_GRID} x0 = [-10.0, -10.0, 0.0] dx = [2.0, 2.0, 0.0] N = [10,10,0] \\end{BACKGROUND_GRID} If there is no MODEL block, then the BACKGROUND_GRID block will define the Cartesian mesh that will be generated, with the lower left point located at x0 , grid spacing dx , and N elements in each direction. For now, the z components must be zero so that the grid is in the x-y plane. The example above creates a uniform background grid with lower left corner at (-10,10) and upper right corner at (10,10). Alternatively, if there is an outer boundary curve, you want to specify the background grid size and let HOHQMesh compute the rest of the parameters: \\begin{BACKGROUND_GRID} background grid size = [2.0,2.0,0.0] \\end{BACKGROUND_GRID} This is the equivalent of dx in the previous incarnation. Note : In general you want to choose the grid size to be the same in each direction for the algorithms that make the mesh conforming to work properly. They can differ if a Cartesian mesh is being generated.","title":"The Background Grid"},{"location":"the-control-input/#the-smoother","text":"It is generally necessary to smooth the mesh after it is generated. Smoothing is done by the Smoother. The SPRING_SMOOTHER uses a spring-dashpot model and time relaxation to smooth the mesh. There are two spring topologies \u201cLinearSpring\u201d and \u201cLinearAndCrossbarSpring\u201d. The first only has springs between the nodes along the edges. The latter also puts springs along the diagonals of an element. The latter is preferred. The springs have a spring constant associated with them and a dashpot with a damping coefficient. The nodes have mass. The linear ODE system that describes the motion of the nodes is integrated with a forward Euler (Explicit!) approximation for which a time step and number of time steps are given. The SPRING_SMOOTHER block, if one is used (Recommended!) is \\begin{SPRING_SMOOTHER} smoothing = ON **or** OFF (Optional) smoothing type = LinearAndCrossbarSpring **or** LinearSpring spring constant = 1.0 (Optional) mass = 1.0 (Optional) rest length = 0.0 (Optional) damping coefficient = 5.0 (Optional) number of iterations = 20 time step = 0.1 (Optional) \\end{SPRING_SMOOTHER} Just leave out any of the optional parameters if you want the default values to be used. The default values should be sufficient, but the additional flexibility might be useful on occasion. (The architecture is designed for developers to add different (better!) smoothers, and hence the name \"SPRING_SMOOTHER\".)","title":"The Smoother"},{"location":"the-control-input/#refinement-regions","text":"Fig. 15. Two refinement centers and a refinement line Manual scaling of the mesh size can be performed by including any combination of Refinement Centers Refinement Lines","title":"Refinement Regions"},{"location":"the-control-input/#refinement-centers","text":"It is possible to ask HOHQMesh to locally refine the mesh at particular locations. This is done with a REFINEMENT_CENTER placed as desired. Two types of centers are available. One is \u201csmooth\u201d, which refines near a specified point and gradually de-refines towards the neighboring mesh size. The other is \u201csharp\u201d, which keeps the refined size in the neighborhood of the center. The desired mesh size and the size of the center are also parameters. An example of a refinement center is \\begin{REFINEMENT_CENTER} type = smooth **or** sharp x0 = [1.0,1.0,0.0] h = 0.20 w = 0.5 \\end{REFINEMENT_CENTER} This will place a center at (1,1,0) with mesh size of 0.2 over a circular region of radius 0.5 . Any number of RefinementCenters can be included. The order in which they are defined is not important.","title":"Refinement Centers"},{"location":"the-control-input/#refinement-lines","text":"The mesh can also be refined along a line using a REFINEMENT_LINE . Like the centers, there are two types, \u201csmooth\u201d and \u201csharp\u201d. To refine along a line, include a block of the form \\begin{REFINEMENT_LINE} type = smooth **or** sharp x0 = [-3.5,-3.5,0.0] x1 = [3.0,3.0,0.0] h = 0.20 w = 0.5 \\end{REFINEMENT_LINE} Here, x0 and x1 are the starting and ending points of the line, h is the desired mesh size and w tells how far out from the line the refinement extends. An example of center and line refinements can be seen in Fig. 15.","title":"Refinement Lines"},{"location":"the-control-input/#refinement-region-definition","text":"Refinement regions are defined within a REFINEMENT_REGIONS block, e.g. \\begin{REFINEMENT_REGIONS} \\begin{REFINEMENT_LINE} type = nonsmooth x0 = [-3.0,-3.0,0.0] x1 = [3.0,3.0,0.0] h = 0.3 w = 0.3 \\end{REFINEMENT_LINE} \\begin{REFINEMENT_CENTER} type = smooth x0 = [3.0,-3.0,0.0] h = 0.1 w = 0.3 \\end{REFINEMENT_CENTER} \\end{REFINEMENT_REGIONS} The ordering of the blocks within the REFINEMENT_REGIONS block is arbitrary.","title":"Refinement Region Definition"},{"location":"the-model/","text":"The Model \u00b6 At the present time, HOHQMesh is designed to generate quadrilateral meshes in general two dimensional geometries like those shown below in Fig. 13, and extrusions thereof to get three dimensional hex meshes. Fig. 13. Meshable regions The two dimensional domain to be meshed can be bounded by at most one exterior boundary curve (which can be composed of a chain or curves), as in 13(a) and 13(b), above, and any number of interior boundary curves that create holes. For purely external problems, a rectangular outer boundary can be implicitly included, as shown in 13(c). If no model block is included at all, then a purely Cartesian mesh will be created using parameters set in the control file. Boundary Curves \u00b6 Fig. 14. A mesh whose model uses all curve types. Three `END_POINTS_LINE`s for the outer triangle. A `SPLINE_CURVE` for the free-form inner boundary, and circles defined by a `PARAMETRIC_EQUATION_CURVE` and by a `CIRCULAR_ARC` curve (Examples/2D/AllFeatures). Boundaries are constructed as closed chains of parametrized curves, with the parameter in the interval [0,1], oriented counter-clockwise. The chains can have one or more segments as seen in Fig. 13. In Fig. 13a the outer boundary is constructed from six curves, whereas in Fig. 13b it is bounded by a single one. The inner boundaries in Fig. 13a are a single circle and a square constructed by a chain of four lines. In Fig. 14, the outer triangle is constructed as a chain of straight lines defined as END_POINTS_LINE s. A curve is defined by a block \\begin{curve_type} ... \\end{curve_type} It is given a name so that boundary conditions can be applied segment-by-segment to a chain. Currently there are four types of curves that can be defined: Curves defined by equation components. Cubic spline interpolants of a set of nodal points. Straight lines between two points. Circular arcs. Fig. 14 is an example that uses all four curve-type definitions (Examples/2D/AllFeatures). The architecture is designed for developers to easily add curve definitions in the future by creating subclasses of the SMCurveClass. The Parametric Equation Curve Definition. \u00b6 Curves can be defined by strings that define the equations for the (x,y,z) components of the curve using the PARAMETRIC_EQUATION_CURVE type. An example block for this kind of curve is \\begin{PARAMETRIC_EQUATION_CURVE} name = circle xEqn = x(t) = 14.0*cos(2*pi*t) yEqn = y(t) = 14.0*sin(2*pi*t) zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} The first line defines the name, followed by the x- , y- and z- equation definitions. Right now, only two-dimensional meshes in the x-y plane can be generated, so the z=0 equation must be set this way . The example block defines a closed circular curve of radius 14 named \u201ccircle\u201d. The indenting is optional, as is the ordering of the keys within the block. The keywords are \u201cname\u201d, \u201cxEqn\u201d, etc. and must be spelled correctly or an error will be posted when the model is read in. The zEqn keyword line is optional and can be left out. The equations can be any legal representations of an equation as is standard in most computer languages. The first part, before the equals sign defines the parameter variable, in this case, t . On the right hand side is the formula that defines the curve. Exponentiation is defined as in BASIC, like t^2 . For convenience, the constant pi is defined. Like BASIC, literals are defined as double precision values. There are no integer quantities. Standard functions like sin, cos, tan, atan, log, log10, exp, etc. are also available for use. The Spline Curve Definition \u00b6 The second type of curve is the SPLINE_CURVE type, which fits a cubic spline to a set of knots at given parameter values. The parameterization does not have to be uniform. An example of a spline-defined curve is \\begin{SPLINE_CURVE} name = SplineBoundaryCurve nKnots = 9 \\begin{SPLINE_DATA} 0.000000000000000 -3.50000000000000 3.50000000000000 0.0 3.846153846153846E-002 -3.20000000000000 5.00000000000 0.0 7.692307692307693E-002 -2.00000000000000 6.00000000000 0.0 0.769230769230769 0.000000000000000 -1.00000000000000 0.0 0.807692307692308 -1.00000000000000 -1.00000000000000 0.0 0.846153846153846 -2.00000000000000 -0.800000000000000 0.0 0.884615384615385 -2.50000000000000 0.000000000000000 0.0 0.923076923076923 -3.00000000000000 1.00000000000000 0.0 1.00000000000000 -3.50000000000000 3.50000000000000 0.0 \\end{SPLINE_DATA} \\end{SPLINE_CURVE} As before, the first line after the \\begin is the name of the curve. It is followed by the number of nodes in the spline. The data columns that follow are the nodes given by t j ,x j ,y j ,z j . This particular spline is closed, so the location of the last node is the same as the first. Again, the z j values must currently be zero to ensure that curves are in the x-y plane. Endpoints Line Definition \u00b6 The next type of curve is the END_POINTS_LINE type that takes two end points and puts a straight line between them. An example is \\begin{END_POINTS_LINE} name = B1 xStart = [0.0,1.0,0.0] xEnd = [2.0,1.0,0.0] \\end{END_POINTS_LINE} where the x,y,z values of the point are specified in the array denoted as [x,y,z]. For now, the z component must be 0.0. Circular Arc Curve \u00b6 The final type of curve defines a circular arc. The angles can be defined either in terms of degrees or radians. If the (optional) units keyword is not included, the default is radians. \\begin{CIRCULAR_ARC} name = circle units = degrees center = [0.0,0,0,0.0] radius = 4.0 start angle = 0.0 end angle = 180.0 \\end{CIRCULAR_ARC} Boundary Chains \u00b6 To allow complex boundary curves and to allow different portions of a boundary to have different boundary conditions applied, curves can be chained together into a closed curve. A chain is defined by curves specified (in order) within a \\begin{CHAIN} ... \\end{CHAIN} block. Any number of curves can be chained together. The chain itself is also given a name. An example of a chain that defines the boundary of a unit square is \\begin{CHAIN} name = UnitSquare \\begin{PARAMETRIC_EQUATION_CURVE} name = bottom xEqn = f(t) = t yEqn = f(t) = 0 zEqn = f(t) = 0 \\end{PARAMETRIC_EQUATION_CURVE} \\begin{PARAMETRIC_EQUATION_CURVE} name = right xEqn = f(t) = 1 yEqn = f(t) = t zEqn = f(t) = 0 \\end{PARAMETRIC_EQUATION_CURVE} \\begin{PARAMETRIC_EQUATION_CURVE} name = top xEqn = f(t) = 1-t yEqn = f(t) = 1 zEqn = f(t) = 0 \\end{PARAMETRIC_EQUATION_CURVE} \\begin{PARAMETRIC_EQUATION_CURVE} name = bottom xEqn = f(t) = 0 yEqn = f(t) = 1-t zEqn = f(t) = 0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{CHAIN} Again, the indentation is for readability only, as is the line spacing between the blocks. (Blank lines and lines starting with \u201c%\u201d are ignored.) Also remember that the chain is defined counter-clockwise, and the curves within the chain must be ordered and oriented properly. Chains cannot be chained together. The Model Definition \u00b6 The model (there is at most one) defines the region that is to be meshed. It is marked by \\begin{MODEL} ... \\end{MODEL} If the control file does not contain a model block, a Cartesian mesh will be generated. The model contains at most one outer boundary chain and any number of inner boundary chains. The outer boundary chain (if there is one) is defined by \\begin{OUTER_BOUNDARY} ... \\end{OUTER_BOUNDARY} Within the OUTER_BOUNDARY block is a list of boundary curves that form a chain. There is no need to explicitly chain (by way of \\begin{CHAIN} ... \\end{CHAIN} ) the curves for the outer boundary, as that is implied. Inner boundaries (if any) are defined within the block \\begin{INNER_BOUNDARIES} ... \\end{INNER_BOUNDARIES} Within this block one defines as many CHAIN s as there are inner boundaries. Each inner boundary must be defined within a chain. (Even if there is only one curve in the chain.) The order in which the CHAIN s are defined is not important. As an example, the following defines a model that has a single circular outer boundary and three inner circular boundaries. As usual, indentation is for the reader\u2019s eyes only. Note that between the blocks, comments can be inserted starting with \u201c%\u201d. \\begin{MODEL} \\begin{OUTER_BOUNDARY} \\begin{PARAMETRIC_EQUATION_CURVE} name = outer xEqn = x(t) = 14.0*cos(2*pi*t) yEqn = y(t) = 14.0*sin(2*pi*t) zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{OUTER_BOUNDARY} % % Inner boundaries, if any, are any number of chains % of curves. Each inner boundary is defined within a CHAIN. % \\begin{INNER_BOUNDARIES} \\begin{CHAIN} name = Boundary 1 \\begin{PARAMETRIC_EQUATION_CURVE} name = Circle1 xEqn = f(t) = -10.25 + 0.2*cos(2*pi*t) yEqn = f(t) = 3.0 + 0.2*sin(2*pi*t) zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{CHAIN} \\begin{CHAIN} name = Boundary 2 \\begin{PARAMETRIC_EQUATION_CURVE} name = Circle2 xEqn = f(t) = -5.1 + 1.0*cos(2*pi*t) yEqn = f(t) = 1.0*sin(2*pi*t) - 4.1 zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{CHAIN} \\begin{CHAIN} name = Boundary 3 \\begin{PARAMETRIC_EQUATION_CURVE} name = Circle3 xEqn = f(t) = -12.0 + 0.5*cos(2*pi*t) yEqn = f(t) = 0.5*sin(2*pi*t) - 0.5 zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{CHAIN} \\end{INNER_BOUNDARIES} \\end{MODEL}","title":"The Model"},{"location":"the-model/#the-model","text":"At the present time, HOHQMesh is designed to generate quadrilateral meshes in general two dimensional geometries like those shown below in Fig. 13, and extrusions thereof to get three dimensional hex meshes. Fig. 13. Meshable regions The two dimensional domain to be meshed can be bounded by at most one exterior boundary curve (which can be composed of a chain or curves), as in 13(a) and 13(b), above, and any number of interior boundary curves that create holes. For purely external problems, a rectangular outer boundary can be implicitly included, as shown in 13(c). If no model block is included at all, then a purely Cartesian mesh will be created using parameters set in the control file.","title":"The Model"},{"location":"the-model/#boundary-curves","text":"Fig. 14. A mesh whose model uses all curve types. Three `END_POINTS_LINE`s for the outer triangle. A `SPLINE_CURVE` for the free-form inner boundary, and circles defined by a `PARAMETRIC_EQUATION_CURVE` and by a `CIRCULAR_ARC` curve (Examples/2D/AllFeatures). Boundaries are constructed as closed chains of parametrized curves, with the parameter in the interval [0,1], oriented counter-clockwise. The chains can have one or more segments as seen in Fig. 13. In Fig. 13a the outer boundary is constructed from six curves, whereas in Fig. 13b it is bounded by a single one. The inner boundaries in Fig. 13a are a single circle and a square constructed by a chain of four lines. In Fig. 14, the outer triangle is constructed as a chain of straight lines defined as END_POINTS_LINE s. A curve is defined by a block \\begin{curve_type} ... \\end{curve_type} It is given a name so that boundary conditions can be applied segment-by-segment to a chain. Currently there are four types of curves that can be defined: Curves defined by equation components. Cubic spline interpolants of a set of nodal points. Straight lines between two points. Circular arcs. Fig. 14 is an example that uses all four curve-type definitions (Examples/2D/AllFeatures). The architecture is designed for developers to easily add curve definitions in the future by creating subclasses of the SMCurveClass.","title":"Boundary Curves"},{"location":"the-model/#the-parametric-equation-curve-definition","text":"Curves can be defined by strings that define the equations for the (x,y,z) components of the curve using the PARAMETRIC_EQUATION_CURVE type. An example block for this kind of curve is \\begin{PARAMETRIC_EQUATION_CURVE} name = circle xEqn = x(t) = 14.0*cos(2*pi*t) yEqn = y(t) = 14.0*sin(2*pi*t) zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} The first line defines the name, followed by the x- , y- and z- equation definitions. Right now, only two-dimensional meshes in the x-y plane can be generated, so the z=0 equation must be set this way . The example block defines a closed circular curve of radius 14 named \u201ccircle\u201d. The indenting is optional, as is the ordering of the keys within the block. The keywords are \u201cname\u201d, \u201cxEqn\u201d, etc. and must be spelled correctly or an error will be posted when the model is read in. The zEqn keyword line is optional and can be left out. The equations can be any legal representations of an equation as is standard in most computer languages. The first part, before the equals sign defines the parameter variable, in this case, t . On the right hand side is the formula that defines the curve. Exponentiation is defined as in BASIC, like t^2 . For convenience, the constant pi is defined. Like BASIC, literals are defined as double precision values. There are no integer quantities. Standard functions like sin, cos, tan, atan, log, log10, exp, etc. are also available for use.","title":"The Parametric Equation Curve Definition."},{"location":"the-model/#the-spline-curve-definition","text":"The second type of curve is the SPLINE_CURVE type, which fits a cubic spline to a set of knots at given parameter values. The parameterization does not have to be uniform. An example of a spline-defined curve is \\begin{SPLINE_CURVE} name = SplineBoundaryCurve nKnots = 9 \\begin{SPLINE_DATA} 0.000000000000000 -3.50000000000000 3.50000000000000 0.0 3.846153846153846E-002 -3.20000000000000 5.00000000000 0.0 7.692307692307693E-002 -2.00000000000000 6.00000000000 0.0 0.769230769230769 0.000000000000000 -1.00000000000000 0.0 0.807692307692308 -1.00000000000000 -1.00000000000000 0.0 0.846153846153846 -2.00000000000000 -0.800000000000000 0.0 0.884615384615385 -2.50000000000000 0.000000000000000 0.0 0.923076923076923 -3.00000000000000 1.00000000000000 0.0 1.00000000000000 -3.50000000000000 3.50000000000000 0.0 \\end{SPLINE_DATA} \\end{SPLINE_CURVE} As before, the first line after the \\begin is the name of the curve. It is followed by the number of nodes in the spline. The data columns that follow are the nodes given by t j ,x j ,y j ,z j . This particular spline is closed, so the location of the last node is the same as the first. Again, the z j values must currently be zero to ensure that curves are in the x-y plane.","title":"The Spline Curve Definition"},{"location":"the-model/#endpoints-line-definition","text":"The next type of curve is the END_POINTS_LINE type that takes two end points and puts a straight line between them. An example is \\begin{END_POINTS_LINE} name = B1 xStart = [0.0,1.0,0.0] xEnd = [2.0,1.0,0.0] \\end{END_POINTS_LINE} where the x,y,z values of the point are specified in the array denoted as [x,y,z]. For now, the z component must be 0.0.","title":"Endpoints Line Definition"},{"location":"the-model/#circular-arc-curve","text":"The final type of curve defines a circular arc. The angles can be defined either in terms of degrees or radians. If the (optional) units keyword is not included, the default is radians. \\begin{CIRCULAR_ARC} name = circle units = degrees center = [0.0,0,0,0.0] radius = 4.0 start angle = 0.0 end angle = 180.0 \\end{CIRCULAR_ARC}","title":"Circular Arc Curve"},{"location":"the-model/#boundary-chains","text":"To allow complex boundary curves and to allow different portions of a boundary to have different boundary conditions applied, curves can be chained together into a closed curve. A chain is defined by curves specified (in order) within a \\begin{CHAIN} ... \\end{CHAIN} block. Any number of curves can be chained together. The chain itself is also given a name. An example of a chain that defines the boundary of a unit square is \\begin{CHAIN} name = UnitSquare \\begin{PARAMETRIC_EQUATION_CURVE} name = bottom xEqn = f(t) = t yEqn = f(t) = 0 zEqn = f(t) = 0 \\end{PARAMETRIC_EQUATION_CURVE} \\begin{PARAMETRIC_EQUATION_CURVE} name = right xEqn = f(t) = 1 yEqn = f(t) = t zEqn = f(t) = 0 \\end{PARAMETRIC_EQUATION_CURVE} \\begin{PARAMETRIC_EQUATION_CURVE} name = top xEqn = f(t) = 1-t yEqn = f(t) = 1 zEqn = f(t) = 0 \\end{PARAMETRIC_EQUATION_CURVE} \\begin{PARAMETRIC_EQUATION_CURVE} name = bottom xEqn = f(t) = 0 yEqn = f(t) = 1-t zEqn = f(t) = 0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{CHAIN} Again, the indentation is for readability only, as is the line spacing between the blocks. (Blank lines and lines starting with \u201c%\u201d are ignored.) Also remember that the chain is defined counter-clockwise, and the curves within the chain must be ordered and oriented properly. Chains cannot be chained together.","title":"Boundary Chains"},{"location":"the-model/#the-model-definition","text":"The model (there is at most one) defines the region that is to be meshed. It is marked by \\begin{MODEL} ... \\end{MODEL} If the control file does not contain a model block, a Cartesian mesh will be generated. The model contains at most one outer boundary chain and any number of inner boundary chains. The outer boundary chain (if there is one) is defined by \\begin{OUTER_BOUNDARY} ... \\end{OUTER_BOUNDARY} Within the OUTER_BOUNDARY block is a list of boundary curves that form a chain. There is no need to explicitly chain (by way of \\begin{CHAIN} ... \\end{CHAIN} ) the curves for the outer boundary, as that is implied. Inner boundaries (if any) are defined within the block \\begin{INNER_BOUNDARIES} ... \\end{INNER_BOUNDARIES} Within this block one defines as many CHAIN s as there are inner boundaries. Each inner boundary must be defined within a chain. (Even if there is only one curve in the chain.) The order in which the CHAIN s are defined is not important. As an example, the following defines a model that has a single circular outer boundary and three inner circular boundaries. As usual, indentation is for the reader\u2019s eyes only. Note that between the blocks, comments can be inserted starting with \u201c%\u201d. \\begin{MODEL} \\begin{OUTER_BOUNDARY} \\begin{PARAMETRIC_EQUATION_CURVE} name = outer xEqn = x(t) = 14.0*cos(2*pi*t) yEqn = y(t) = 14.0*sin(2*pi*t) zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{OUTER_BOUNDARY} % % Inner boundaries, if any, are any number of chains % of curves. Each inner boundary is defined within a CHAIN. % \\begin{INNER_BOUNDARIES} \\begin{CHAIN} name = Boundary 1 \\begin{PARAMETRIC_EQUATION_CURVE} name = Circle1 xEqn = f(t) = -10.25 + 0.2*cos(2*pi*t) yEqn = f(t) = 3.0 + 0.2*sin(2*pi*t) zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{CHAIN} \\begin{CHAIN} name = Boundary 2 \\begin{PARAMETRIC_EQUATION_CURVE} name = Circle2 xEqn = f(t) = -5.1 + 1.0*cos(2*pi*t) yEqn = f(t) = 1.0*sin(2*pi*t) - 4.1 zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{CHAIN} \\begin{CHAIN} name = Boundary 3 \\begin{PARAMETRIC_EQUATION_CURVE} name = Circle3 xEqn = f(t) = -12.0 + 0.5*cos(2*pi*t) yEqn = f(t) = 0.5*sin(2*pi*t) - 0.5 zEqn = z(t) = 0.0 \\end{PARAMETRIC_EQUATION_CURVE} \\end{CHAIN} \\end{INNER_BOUNDARIES} \\end{MODEL}","title":"The Model Definition"},{"location":"three-dimensional-hexahedral-meshes/","text":"Three Dimensional Hexahedral Meshes \u00b6 HOHQMesh can also generate 3D hexahedral meshes by extruding or sweeping a two dimensional mesh. To tell the mesher that you want a hex mesh, you add an algorithm block to the CONTROL_INPUT block for how the 3D extrusion will be done. Currently there are three: Simple extrusion, Simple rotation, and Sweeping. Simple Extrusion \u00b6 Fig. 16. Simple Extrusion of a semi-circular quadrilateral mesh The first hex-meshing algorithm is the SIMPLE_EXTRUSION algorithm. \\begin{SIMPLE_EXTRUSION} direction = 3 height = 8.0 subdivisions = 8 start surface name = bottom end surface name = top \\end{SIMPLE_EXTRUSION} The direction (where x = 1, y = 2, z = 3 ) says which direction the extrusion is done. Note that even though the initial 2D mesh is in the x-y plane, the quad mesh is rotated to give a hex mesh extruded in the requested direction. The height tells how far to extrude. A name is given to the bottom and top faces created by the extrusion so that boundary conditions can be attached. Otherwise, the names of the faces are given by the 2D curve names. Simple Rotation \u00b6 Fig. 17. Simple rotation of the mesh in Fig. 3 The second algorithm is the SIMPLE_ROTATION , which rotates the two dimensional mesh about an axis \\begin{SIMPLE_ROTATION} direction = 1 rotation angle factor = 1.0 subdivisions = 8 start surface name = bottom end surface name = top \\end{SIMPLE_ROTATION} The rotation andle factor is the fraction of pi over which the quad mesh is rotated. An example is shown below of an original two dimensional mesh and its rotation about the x axis (direction = 1) is shown in Fig. 17. Sweeping \u00b6 Fig. 18. Hex mesh generated by sweeping a circular mesh along a curve The most general algorithm for generating hex meshes in HOHQMESH is to sweep a two-dimensional mesh along a prescribed curve, SWEEP_ALONG_CURVE . To sweep along a curve, one does two things: Add a SWEEP_ALONG_CURVE block to the CONTOL_INPUT block and Add the curve along which the sweeping is to be done to the MODEL block. There are currently two sweeping algorithms available. The default is a simple rotation algorithm that has no method to counteract twisting of the mesh as it follows the curve. (Think of a roller-coaster that can turn upside down as it follows a curved track.) The default algorithm is exact so will sweep the curve to high order, but will only produce an untwisted mesh if the curve is planar. The second is a parallel transport algorithm due to Hanson and Ma that keeps arbitrary vector in a particular orientation with respect to its initial direction. The parallel transport approach minimizes the twisting of the hex mesh, but is only second order accurate. [A fourth order algorithm may be implemented in the future.] To implement sweeping, include a SWEEP_ALONG_CURVE block in the CONTOL_INPUT block: \\begin{SWEEP_ALONG_CURVE} algorithm = Hanson (optional) subdivisions per segment = 8 start surface name = bottom end surface name = top \\end{SWEEP_ALONG_CURVE} The algorithm keyword is optional. If not present, the sweeping will not include the parallel transport correction. Since the sweep curve can be a chain with slope or curvature singularities, the number of subdivisions per segment is defined. This ensures that a singularity occurs along element boundaries so that accuracy is not lost. The curve itself is defined in the MODEL block. \\begin{SWEEP_CURVE} ... \\end{SWEEP_CURVE} The SWEEP_CURVE block implicitly defines a CHAIN , like the OUTER_BOUNDARY block, and so only needs a list of curves to define the sweep. Scaling \u00b6 Fig. 19. Hex mesh generated by sweeping and scaling along a curve The mesh can also be scaled in the direction normal to the sweep curve when sweeping is used. To scale the mesh, add a \\begin{SWEEP_SCALE_FACTOR} ... \\end{SWEEP_SCALE_FACTOR} block to the MODEL . Like the SWEEP_CURVE and OUTER_BOUNDARY blocks, the SWEEP_SCALE_FACTOR block implicitly defines a CHAIN . You do not need to have the number chain segments match the number in the SWEEP_ALONG_CURVE block, but it is probably best to not introduce slope or curvature singularities except at element interfaces. The equation for the scaling is scalar PARAMETRIC_EQUATION (as opposed to a PARAMETRIC_EQUATION_CURVE ). It is defined, for example like this: \\begin{PARAMETRIC_EQUATION} eqn = r(t) = 1.0 + 2.5*t*(1-t) \\end{PARAMETRIC_EQUATION} Bottom Topography \u00b6 Fig. 20. Simple Extrusion of a semi-circular mesh with bottom topography When using the SIMPLE_EXTRUSION algorithm, bottom topography can be added as shown below: At this time, the bottom topography is defined only as an equation in a TOPOGRAPHY block, e.g. \\begin{TOPOGRAPHY} eqn = h(x,y) = x^2 + y^2 \\end{TOPOGRAPHY} The height function takes two arguments, which are the physical x-y coordinates, unlike the parametric coordinates that define boundary curves. Currently the only way to define bottom topography is through an equation as above. However that limitation can be overcome by implementing other bottom topography subclasses.","title":"Three Dimensional Hexahedral Meshes"},{"location":"three-dimensional-hexahedral-meshes/#three-dimensional-hexahedral-meshes","text":"HOHQMesh can also generate 3D hexahedral meshes by extruding or sweeping a two dimensional mesh. To tell the mesher that you want a hex mesh, you add an algorithm block to the CONTROL_INPUT block for how the 3D extrusion will be done. Currently there are three: Simple extrusion, Simple rotation, and Sweeping.","title":"Three Dimensional Hexahedral Meshes"},{"location":"three-dimensional-hexahedral-meshes/#simple-extrusion","text":"Fig. 16. Simple Extrusion of a semi-circular quadrilateral mesh The first hex-meshing algorithm is the SIMPLE_EXTRUSION algorithm. \\begin{SIMPLE_EXTRUSION} direction = 3 height = 8.0 subdivisions = 8 start surface name = bottom end surface name = top \\end{SIMPLE_EXTRUSION} The direction (where x = 1, y = 2, z = 3 ) says which direction the extrusion is done. Note that even though the initial 2D mesh is in the x-y plane, the quad mesh is rotated to give a hex mesh extruded in the requested direction. The height tells how far to extrude. A name is given to the bottom and top faces created by the extrusion so that boundary conditions can be attached. Otherwise, the names of the faces are given by the 2D curve names.","title":"Simple Extrusion"},{"location":"three-dimensional-hexahedral-meshes/#simple-rotation","text":"Fig. 17. Simple rotation of the mesh in Fig. 3 The second algorithm is the SIMPLE_ROTATION , which rotates the two dimensional mesh about an axis \\begin{SIMPLE_ROTATION} direction = 1 rotation angle factor = 1.0 subdivisions = 8 start surface name = bottom end surface name = top \\end{SIMPLE_ROTATION} The rotation andle factor is the fraction of pi over which the quad mesh is rotated. An example is shown below of an original two dimensional mesh and its rotation about the x axis (direction = 1) is shown in Fig. 17.","title":"Simple Rotation"},{"location":"three-dimensional-hexahedral-meshes/#sweeping","text":"Fig. 18. Hex mesh generated by sweeping a circular mesh along a curve The most general algorithm for generating hex meshes in HOHQMESH is to sweep a two-dimensional mesh along a prescribed curve, SWEEP_ALONG_CURVE . To sweep along a curve, one does two things: Add a SWEEP_ALONG_CURVE block to the CONTOL_INPUT block and Add the curve along which the sweeping is to be done to the MODEL block. There are currently two sweeping algorithms available. The default is a simple rotation algorithm that has no method to counteract twisting of the mesh as it follows the curve. (Think of a roller-coaster that can turn upside down as it follows a curved track.) The default algorithm is exact so will sweep the curve to high order, but will only produce an untwisted mesh if the curve is planar. The second is a parallel transport algorithm due to Hanson and Ma that keeps arbitrary vector in a particular orientation with respect to its initial direction. The parallel transport approach minimizes the twisting of the hex mesh, but is only second order accurate. [A fourth order algorithm may be implemented in the future.] To implement sweeping, include a SWEEP_ALONG_CURVE block in the CONTOL_INPUT block: \\begin{SWEEP_ALONG_CURVE} algorithm = Hanson (optional) subdivisions per segment = 8 start surface name = bottom end surface name = top \\end{SWEEP_ALONG_CURVE} The algorithm keyword is optional. If not present, the sweeping will not include the parallel transport correction. Since the sweep curve can be a chain with slope or curvature singularities, the number of subdivisions per segment is defined. This ensures that a singularity occurs along element boundaries so that accuracy is not lost. The curve itself is defined in the MODEL block. \\begin{SWEEP_CURVE} ... \\end{SWEEP_CURVE} The SWEEP_CURVE block implicitly defines a CHAIN , like the OUTER_BOUNDARY block, and so only needs a list of curves to define the sweep.","title":"Sweeping"},{"location":"three-dimensional-hexahedral-meshes/#scaling","text":"Fig. 19. Hex mesh generated by sweeping and scaling along a curve The mesh can also be scaled in the direction normal to the sweep curve when sweeping is used. To scale the mesh, add a \\begin{SWEEP_SCALE_FACTOR} ... \\end{SWEEP_SCALE_FACTOR} block to the MODEL . Like the SWEEP_CURVE and OUTER_BOUNDARY blocks, the SWEEP_SCALE_FACTOR block implicitly defines a CHAIN . You do not need to have the number chain segments match the number in the SWEEP_ALONG_CURVE block, but it is probably best to not introduce slope or curvature singularities except at element interfaces. The equation for the scaling is scalar PARAMETRIC_EQUATION (as opposed to a PARAMETRIC_EQUATION_CURVE ). It is defined, for example like this: \\begin{PARAMETRIC_EQUATION} eqn = r(t) = 1.0 + 2.5*t*(1-t) \\end{PARAMETRIC_EQUATION}","title":"Scaling"},{"location":"three-dimensional-hexahedral-meshes/#bottom-topography","text":"Fig. 20. Simple Extrusion of a semi-circular mesh with bottom topography When using the SIMPLE_EXTRUSION algorithm, bottom topography can be added as shown below: At this time, the bottom topography is defined only as an equation in a TOPOGRAPHY block, e.g. \\begin{TOPOGRAPHY} eqn = h(x,y) = x^2 + y^2 \\end{TOPOGRAPHY} The height function takes two arguments, which are the physical x-y coordinates, unlike the parametric coordinates that define boundary curves. Currently the only way to define bottom topography is through an equation as above. However that limitation can be overcome by implementing other bottom topography subclasses.","title":"Bottom Topography"},{"location":"updating-spack-packages/","text":"Updating Spack Packages \u00b6 When new releases of HOHQMesh are made, you can contribute the new release to the spack packages. Before making an update to the Spack package, you should familiarize yourself with the Spack packaging guide . To add a new HOHQMesh release to Spack, perform the following steps: Fork the Spack repository on GitHub. Install and initialize spack on your local system from your fork git clone https://github.com/YOUR GITHUB ACCOUNT/spack.git ~/spack source ~/spack/share/spack/setup-env.sh Open the HOHQMesh package for editing spack edit hohqmesh Add a new version metadata item to the hohqmesh package. The first argument is the version name as it will appear in the spack package manager. Use the tag argument to specify the name of the tag as it appears in the HOHQMesh repository. As an example, a new version line for v1.0.1 is shown below. version('v1.0.1', tag='v1.0.1') (Optional) If you would like to be noted as a maintainer, add your GitHub handle to the maintainers list. Maintainers will be notified if Spack users experience issues installing HOHQMesh and when modifications are being made to the HOHQMesh package in Spack. maintainers = ['schoonovernumerics','your-github-handle'] When you are finished editing, save the package file. You can verify the new version is registered in your local repository by obtaining a spec for HOHQMesh at the new version you've added. spack spec hohqmesh@v1.0.1 Test to make sure the installation works spack install hohqmesh@v1.0.1 Run the spack style command to ensure that you are meeting Spack's style requirements. When ready, commit your changes and push them to your GitHub repository. Open a Pull Request against github.com/spack/spack to merge your changes with the spack/spack/develop branch.","title":"Updating Spack Packages"},{"location":"updating-spack-packages/#updating-spack-packages","text":"When new releases of HOHQMesh are made, you can contribute the new release to the spack packages. Before making an update to the Spack package, you should familiarize yourself with the Spack packaging guide . To add a new HOHQMesh release to Spack, perform the following steps: Fork the Spack repository on GitHub. Install and initialize spack on your local system from your fork git clone https://github.com/YOUR GITHUB ACCOUNT/spack.git ~/spack source ~/spack/share/spack/setup-env.sh Open the HOHQMesh package for editing spack edit hohqmesh Add a new version metadata item to the hohqmesh package. The first argument is the version name as it will appear in the spack package manager. Use the tag argument to specify the name of the tag as it appears in the HOHQMesh repository. As an example, a new version line for v1.0.1 is shown below. version('v1.0.1', tag='v1.0.1') (Optional) If you would like to be noted as a maintainer, add your GitHub handle to the maintainers list. Maintainers will be notified if Spack users experience issues installing HOHQMesh and when modifications are being made to the HOHQMesh package in Spack. maintainers = ['schoonovernumerics','your-github-handle'] When you are finished editing, save the package file. You can verify the new version is registered in your local repository by obtaining a spec for HOHQMesh at the new version you've added. spack spec hohqmesh@v1.0.1 Test to make sure the installation works spack install hohqmesh@v1.0.1 Run the spack style command to ensure that you are meeting Spack's style requirements. When ready, commit your changes and push them to your GitHub repository. Open a Pull Request against github.com/spack/spack to merge your changes with the spack/spack/develop branch.","title":"Updating Spack Packages"},{"location":"images/","text":"Notes on figures \u00b6 Command for creating small Trixi: convert TrixiInside.png -resize 64x64 TrixiInside_small.png Command for turning background transparent: convert TrixiInside_small.png -fill 'transparent' -fuzz 5 % -draw 'color 0,0 floodfill' TrixiInside_small_transparent.png Command for turning a single color completely transparent: convert TrixiInside.png -fuzz 5 % -transparent '#52586E' TrixiInside_transparent.png","title":"Notes on figures"},{"location":"images/#notes-on-figures","text":"Command for creating small Trixi: convert TrixiInside.png -resize 64x64 TrixiInside_small.png Command for turning background transparent: convert TrixiInside_small.png -fill 'transparent' -fuzz 5 % -draw 'color 0,0 floodfill' TrixiInside_small_transparent.png Command for turning a single color completely transparent: convert TrixiInside.png -fuzz 5 % -transparent '#52586E' TrixiInside_transparent.png","title":"Notes on figures"}]}